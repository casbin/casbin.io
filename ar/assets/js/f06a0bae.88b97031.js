"use strict";(globalThis.webpackChunkcasbin_website_v2=globalThis.webpackChunkcasbin_website_v2||[]).push([[5618],{6863(e,i,t){t.r(i),t.d(i,{assets:()=>l,contentTitle:()=>r,default:()=>p,frontMatter:()=>a,metadata:()=>n,toc:()=>c});const n=JSON.parse('{"id":"policy-subset-loading","title":"Loading Policy Subsets","description":"\u062a\u062d\u0645\u064a\u0644 \u0627\u0644\u0633\u064a\u0627\u0633\u0627\u062a \u0627\u0644\u0645\u0635\u0641\u0627\u0629","source":"@site/i18n/ar/docusaurus-plugin-content-docs/current/PolicySubsetLoading.mdx","sourceDirName":".","slug":"/policy-subset-loading","permalink":"/ar/docs/policy-subset-loading","draft":false,"unlisted":false,"editUrl":"https://github.com/casbin/casbin-website-v2/edit/master/docs/PolicySubsetLoading.mdx","tags":[],"version":"current","frontMatter":{"id":"policy-subset-loading","title":"Loading Policy Subsets","description":"\u062a\u062d\u0645\u064a\u0644 \u0627\u0644\u0633\u064a\u0627\u0633\u0627\u062a \u0627\u0644\u0645\u0635\u0641\u0627\u0629","keywords":["filtered policies","policy subset","performance optimization"],"authors":["hsluoyz"]},"sidebar":"docs","previous":{"title":"Policy Storage","permalink":"/ar/docs/policy-storage"},"next":{"title":"Use Cases","permalink":"/ar/docs/category/use-cases"}}');var o=t(4848),s=t(8453);const a={id:"policy-subset-loading",title:"Loading Policy Subsets",description:"\u062a\u062d\u0645\u064a\u0644 \u0627\u0644\u0633\u064a\u0627\u0633\u0627\u062a \u0627\u0644\u0645\u0635\u0641\u0627\u0629",keywords:["filtered policies","policy subset","performance optimization"],authors:["hsluoyz"]},r=void 0,l={},c=[];function d(e){const i={code:"code",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(i.p,{children:"Some adapters support filtered policy loading. This capability loads only a subset of policies from storage based on specified criteria, enabling efficient enforcement in large multi-tenant environments where loading all policies would create a performance bottleneck."}),"\n",(0,o.jsxs)(i.p,{children:["To load filtered policies with a supported adapter, call ",(0,o.jsx)(i.code,{children:"LoadFilteredPolicy"}),". The filter format depends on the adapter implementation. The ",(0,o.jsx)(i.code,{children:"SavePolicy"})," method is disabled when operating with filtered policies to prevent accidental data loss."]}),"\n",(0,o.jsx)(i.p,{children:"Here's an example using the built-in filtered file adapter with an RBAC model that includes domains. This filter restricts loaded policies to a single domain, excluding all policies for other domains:"}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-go",children:'import (\n    "github.com/casbin/casbin/v3"\n    fileadapter "github.com/casbin/casbin/v3/persist/file-adapter"\n)\n\nenforcer, _ := casbin.NewEnforcer()\n\nadapter := fileadapter.NewFilteredAdapter("examples/rbac_with_domains_policy.csv")\nenforcer.InitWithAdapter("examples/rbac_with_domains_model.conf", adapter)\n\nfilter := &fileadapter.Filter{\n    P: []string{"", "domain1"},\n    G: []string{"", "", "domain1"},\n}\nenforcer.LoadFilteredPolicy(filter)\n\n// The loaded policy now only contains the entries pertaining to "domain1".\n'})}),"\n",(0,o.jsxs)(i.p,{children:["The ",(0,o.jsx)(i.code,{children:"LoadIncrementalFilteredPolicy"})," method provides similar functionality but appends filtered policies to existing policies rather than replacing them. This incremental approach lets you build up policies from multiple filtered loads."]})]})}function p(e={}){const{wrapper:i}={...(0,s.R)(),...e.components};return i?(0,o.jsx)(i,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},8453(e,i,t){t.d(i,{R:()=>a,x:()=>r});var n=t(6540);const o={},s=n.createContext(o);function a(e){const i=n.useContext(s);return n.useMemo(function(){return"function"==typeof e?e(i):{...i,...e}},[i,e])}function r(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:a(e.components),n.createElement(s.Provider,{value:i},e.children)}}}]);