"use strict";(globalThis.webpackChunkcasbin_website_v2=globalThis.webpackChunkcasbin_website_v2||[]).push([[8046],{2107(e,t,n){n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"how-it-works","title":"How It Works","description":"Casbin\u306e\u4ed5\u7d44\u307f","source":"@site/i18n/ja/docusaurus-plugin-content-docs/current/HowItWorks.mdx","sourceDirName":".","slug":"/how-it-works","permalink":"/ja/docs/how-it-works","draft":false,"unlisted":false,"editUrl":"https://github.com/casbin/casbin-website-v2/edit/master/docs/HowItWorks.mdx","tags":[],"version":"current","frontMatter":{"id":"how-it-works","title":"How It Works","description":"Casbin\u306e\u4ed5\u7d44\u307f","keywords":["PERM","request","policy","matcher","effect"],"authors":["nodece"]},"sidebar":"docs","previous":{"title":"Get Started","permalink":"/ja/docs/get-started"},"next":{"title":"Tutorials","permalink":"/ja/docs/tutorials"}}');var i=n(4848),r=n(8453);const o={id:"how-it-works",title:"How It Works",description:"Casbin\u306e\u4ed5\u7d44\u307f",keywords:["PERM","request","policy","matcher","effect"],authors:["nodece"]},a=void 0,c={},l=[{value:"Request",id:"request",level:3},{value:"Policy",id:"policy",level:3},{value:"Matcher",id:"matcher",level:3},{value:"Effect",id:"effect",level:3}];function d(e){const t={a:"a",code:"code",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(t.p,{children:["Within Casbin, access control models are represented as CONF files structured around the ",(0,i.jsx)(t.strong,{children:"PERM metamodel (Policy, Effect, Request, Matchers)"}),". Changing your project's authorization mechanism is as straightforward as updating a configuration file. You can build custom access control models by mixing and matching available components\u2014for example, combining RBAC roles with ABAC attributes in a single model that operates on one policy rule set."]}),"\n",(0,i.jsx)(t.p,{children:"The PERM model consists of four core elements: Policy, Effect, Request, and Matchers. These components work together to define how resources and users interact."}),"\n",(0,i.jsx)(t.h3,{id:"request",children:"Request"}),"\n",(0,i.jsx)(t.p,{children:"Specifies the parameters required for access requests. At minimum, a basic request contains three elements in tuple form: subject (the entity requesting access), object (the target resource), and action (the intended operation)."}),"\n",(0,i.jsxs)(t.p,{children:["A typical request definition looks like:\n",(0,i.jsx)(t.code,{children:"r={sub,obj,act}"})]}),"\n",(0,i.jsx)(t.p,{children:"This definition establishes both the parameter names and their sequence as expected by the access control matching function."}),"\n",(0,i.jsx)(t.h3,{id:"policy",children:"Policy"}),"\n",(0,i.jsx)(t.p,{children:"Establishes the structure for access rules. This component defines the field names and their order within policy rule documents."}),"\n",(0,i.jsxs)(t.p,{children:["Example definitions:\n",(0,i.jsx)(t.code,{children:"p={sub, obj, act}"})," or ",(0,i.jsx)(t.code,{children:"p={sub, obj, act, eft}"})]}),"\n",(0,i.jsx)(t.p,{children:'Note: When eft (policy result) isn\'t included in the definition, the result field in policy files is ignored, and matching policies default to "allow".'}),"\n",(0,i.jsx)(t.h3,{id:"matcher",children:"Matcher"}),"\n",(0,i.jsx)(t.p,{children:"Specifies how requests are matched against policies."}),"\n",(0,i.jsxs)(t.p,{children:["Example: ",(0,i.jsx)(t.code,{children:"m = r.sub == p.sub && r.act == p.act && r.obj == p.obj"}),"\nThis straightforward matching rule states that when request parameters (entity, resource, and operation) match those in a policy, that policy's result (",(0,i.jsx)(t.code,{children:"p.eft"}),") applies. The policy result is stored in ",(0,i.jsx)(t.code,{children:"p.eft"}),"."]}),"\n",(0,i.jsx)(t.h3,{id:"effect",children:"Effect"}),"\n",(0,i.jsx)(t.p,{children:"Combines the results from matched policies using logical operations."}),"\n",(0,i.jsxs)(t.p,{children:["Example: ",(0,i.jsx)(t.code,{children:"e = some(where(p.eft == allow))"})]}),"\n",(0,i.jsx)(t.p,{children:'This expression means that if any matching policy evaluates to "allow", the final result is true.'}),"\n",(0,i.jsx)(t.p,{children:"Another example:"}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.code,{children:"e = some(where (p.eft == allow)) && !some(where (p.eft == deny))"})}),"\n",(0,i.jsx)(t.p,{children:'This logical expression requires at least one "allow" policy and zero "deny" policies for the result to be true. Essentially, all matching policies must be "allow"\u2014any "deny" makes the entire result false. When both allow and deny policies match, deny takes precedence.'}),"\n",(0,i.jsx)(t.p,{children:"ACL represents the most fundamental and straightforward model in Casbin. Below is the model CONF for ACL:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-ini",children:"# Request definition\n[request_definition]\nr = sub, obj, act\n\n# Policy definition\n[policy_definition]\np = sub, obj, act\n\n# Policy effect\n[policy_effect]\ne = some(where (p.eft == allow))\n\n# Matchers\n[matchers]\nm = r.sub == p.sub && r.obj == p.obj && r.act == p.act\n\n"})}),"\n",(0,i.jsx)(t.p,{children:"Here's a sample policy for the ACL model:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-csv",children:"p, alice, data1, read\np, bob, data2, write\n"})}),"\n",(0,i.jsx)(t.p,{children:"This policy grants:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"alice: read access to data1"}),"\n",(0,i.jsx)(t.li,{children:"bob: write access to data2"}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"Multi-line mode is supported by appending '' at line endings:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-ini",children:"# Matchers\n[matchers]\nm = r.sub == p.sub && r.obj == p.obj \\\n  && r.act == p.act\n"})}),"\n",(0,i.jsxs)(t.p,{children:["For ABAC users, the 'in' operator is available in the Casbin ",(0,i.jsx)(t.strong,{children:"golang"})," implementation (not yet supported in jCasbin and Node-Casbin):"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-ini",children:"# Matchers\n[matchers]\nm = r.obj == p.obj && r.act == p.act || r.obj in ('data2', 'data3')\n"})}),"\n",(0,i.jsxs)(t.p,{children:["Important: Ensure the array length exceeds ",(0,i.jsx)(t.strong,{children:"1"}),", otherwise a panic will occur."]}),"\n",(0,i.jsxs)(t.p,{children:["For additional operators, see ",(0,i.jsx)(t.a,{href:"https://github.com/casbin/govaluate",children:"govaluate"}),"."]})]})}function h(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453(e,t,n){n.d(t,{R:()=>o,x:()=>a});var s=n(6540);const i={},r=s.createContext(i);function o(e){const t=s.useContext(r);return s.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),s.createElement(r.Provider,{value:t},e.children)}}}]);