"use strict";(globalThis.webpackChunkcasbin_website_v2=globalThis.webpackChunkcasbin_website_v2||[]).push([[5136],{8306(e,n,s){s.r(n),s.d(n,{assets:()=>o,contentTitle:()=>c,default:()=>p,frontMatter:()=>a,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"abac","title":"ABAC","description":"ABAC berdasarkan Casbin","source":"@site/i18n/ms/docusaurus-plugin-content-docs/current/ABAC.mdx","sourceDirName":".","slug":"/abac","permalink":"/ms/docs/abac","draft":false,"unlisted":false,"editUrl":"https://github.com/casbin/casbin-website-v2/edit/master/docs/ABAC.mdx","tags":[],"version":"current","frontMatter":{"id":"abac","title":"ABAC","description":"ABAC berdasarkan Casbin","keywords":["ABAC","ABAC model"],"authors":["hsluoyz"]},"sidebar":"docs","previous":{"title":"ReBAC","permalink":"/ms/docs/rebac"},"next":{"title":"PBAC","permalink":"/ms/docs/pbac"}}');var i=s(4848),t=s(8453);const a={id:"abac",title:"ABAC",description:"ABAC berdasarkan Casbin",keywords:["ABAC","ABAC model"],authors:["hsluoyz"]},c=void 0,o={},l=[{value:"Understanding ABAC",id:"understanding-abac",level:2},{value:"Using ABAC",id:"using-abac",level:2},{value:"Handling Complex ABAC Requirements",id:"handling-complex-abac-requirements",level:2}];function d(e){const n={admonition:"admonition",code:"code",h2:"h2",li:"li",ol:"ol",p:"p",pre:"pre",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h2,{id:"understanding-abac",children:"Understanding ABAC"}),"\n",(0,i.jsx)(n.p,{children:"Attribute-Based Access Control (ABAC) determines access permissions by evaluating the properties of subjects, objects, and actions rather than relying solely on identity strings. While standards like XACML provide comprehensive but complex ABAC implementations, Casbin offers a streamlined approach where structs or class instances replace simple string identifiers."}),"\n",(0,i.jsx)(n.p,{children:"Consider this basic ABAC configuration:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ini",children:"[request_definition]\nr = sub, obj, act\n\n[policy_definition]\np = sub, obj, act\n\n[policy_effect]\ne = some(where (p.eft == allow))\n\n[matchers]\nm = r.sub == r.obj.Owner\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The matcher references ",(0,i.jsx)(n.code,{children:"r.obj.Owner"}),", expecting ",(0,i.jsx)(n.code,{children:"r.obj"})," to be a structured object rather than a plain string. When you call ",(0,i.jsx)(n.code,{children:"Enforce()"}),", Casbin uses reflection to access the ",(0,i.jsx)(n.code,{children:"Owner"})," field from the provided object."]}),"\n",(0,i.jsx)(n.p,{children:"A typical resource structure looks like this:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:"type testResource struct {\n    Name  string\n    Owner string\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"For JSON-based parameter passing, enable JSON request handling:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:'e, _ := NewEnforcer("examples/abac_model.conf")\ne.EnableAcceptJsonRequest(true)\n\ndata1Json := `{ "Name": "data1", "Owner": "bob"}`\n\nok, err := e.Enforce("alice", data1Json, "read")\nif err != nil {\n    // Handle JSON parsing errors\n    fmt.Printf("Enforcement failed: %v\\n", err)\n    return\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["When JSON request handling is enabled, Casbin automatically detects and parses strings that begin with ",(0,i.jsx)(n.code,{children:"{"})," or ",(0,i.jsx)(n.code,{children:"["}),". If a string looks like JSON but contains invalid syntax, ",(0,i.jsx)(n.code,{children:"Enforce()"})," returns a clear error message indicating which parameter failed to parse. Plain strings that don't start with JSON delimiters are passed through unchanged, avoiding unnecessary parsing attempts."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:'// Valid JSON - automatically parsed\nvalidJSON := `{"Name": "alice", "Age": 25}`\nok, err := e.Enforce(validJSON, "data1", "read")  // Works correctly\n\n// Invalid JSON - returns descriptive error\ninvalidJSON := `{"Name": "alice",}`  // Trailing comma is invalid in JSON\nok, err := e.Enforce(invalidJSON, "data1", "read")\n// Returns: "failed to parse JSON parameter at index 0: ..."\n\n// Plain string - no parsing attempted\nplainString := "alice"\nok, err := e.Enforce(plainString, "data1", "read")  // Treated as plain string\n'})}),"\n",(0,i.jsx)(n.admonition,{type:"note",children:(0,i.jsx)(n.p,{children:"Enabling JSON parameter support introduces a performance overhead of approximately 1.1 to 1.5x."})}),"\n",(0,i.jsx)(n.h2,{id:"using-abac",children:"Using ABAC"}),"\n",(0,i.jsx)(n.p,{children:"Implementing ABAC requires two steps:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Reference attributes within your model matcher."}),"\n",(0,i.jsxs)(n.li,{children:["Supply struct or class instances as arguments to ",(0,i.jsx)(n.code,{children:"Enforce()"}),"."]}),"\n"]}),"\n",(0,i.jsx)(n.admonition,{type:"warning",children:(0,i.jsxs)(n.p,{children:["ABAC attribute access works only for request elements (",(0,i.jsx)(n.code,{children:"r.sub"}),", ",(0,i.jsx)(n.code,{children:"r.obj"}),", ",(0,i.jsx)(n.code,{children:"r.act"}),"). Policy elements like ",(0,i.jsx)(n.code,{children:"p.sub"})," cannot use ABAC since policies cannot store struct or class definitions."]})}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsxs)(n.p,{children:["Matchers can reference multiple attributes simultaneously. Example: ",(0,i.jsx)(n.code,{children:"m = r.sub.Domain == r.obj.Domain"}),"."]})}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsxs)(n.p,{children:["When policies require commas that would conflict with CSV parsing, wrap the expression in quotation marks. Example: ",(0,i.jsx)(n.code,{children:'"keyMatch("bob", r.sub.Role)"'})," prevents unwanted splitting."]})}),"\n",(0,i.jsx)(n.h2,{id:"handling-complex-abac-requirements",children:"Handling Complex ABAC Requirements"}),"\n",(0,i.jsxs)(n.p,{children:["While the basic ABAC model works for simple scenarios, real-world authorization often demands intricate rule sets. For such cases, move rule complexity from the model into policies using the ",(0,i.jsx)(n.code,{children:"eval()"})," function."]}),"\n",(0,i.jsxs)(n.p,{children:["Model configuration with ",(0,i.jsx)(n.code,{children:"eval()"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ini",children:"[request_definition]\nr = sub, obj, act\n\n[policy_definition]\np = sub_rule, obj, act\n\n[policy_effect]\ne = some(where (p.eft == allow))\n\n[matchers]\nm = eval(p.sub_rule) && r.obj == p.obj && r.act == p.act\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Here, ",(0,i.jsx)(n.code,{children:"p.sub_rule"})," holds expressions that reference request attributes. These expressions are evaluated dynamically during enforcement."]}),"\n",(0,i.jsx)(n.p,{children:"Policy definitions using attribute-based rules:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csv",children:"p, r.sub.Age > 18, /data1, read\np, r.sub.Age < 60, /data2, write\n"})})]})}function p(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453(e,n,s){s.d(n,{R:()=>a,x:()=>c});var r=s(6540);const i={},t=r.createContext(i);function a(e){const n=r.useContext(t);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),r.createElement(t.Provider,{value:n},e.children)}}}]);