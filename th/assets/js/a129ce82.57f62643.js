"use strict";(self.webpackChunkcasbin_website_v2=self.webpackChunkcasbin_website_v2||[]).push([[8647],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>u});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),d=p(n),u=r,h=d["".concat(s,".").concat(u)]||d[u]||m[u]||o;return n?a.createElement(h,i(i({ref:t},c),{},{components:n})):a.createElement(h,i({ref:t},c))}));function u(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=d;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:r,i[1]=l;for(var p=2;p<o;p++)i[p]=n[p];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},9608:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>h,frontMatter:()=>o,metadata:()=>l,toc:()=>p});var a=n(7462),r=(n(7294),n(3905));const o={id:"syntax-for-models",title:"Syntax for Models",description:"Syntax for Models",keywords:["syntax"],authors:["nodece"]},i=void 0,l={unversionedId:"syntax-for-models",id:"syntax-for-models",title:"Syntax for Models",description:"Syntax for Models",source:"@site/i18n/th/docusaurus-plugin-content-docs/current/SyntaxForModels.mdx",sourceDirName:".",slug:"/syntax-for-models",permalink:"/th/docs/syntax-for-models",draft:!1,editUrl:"https://github.com/casbin/casbin-website-v2/edit/master/docs/SyntaxForModels.mdx",tags:[],version:"current",frontMatter:{id:"syntax-for-models",title:"Syntax for Models",description:"Syntax for Models",keywords:["syntax"],authors:["nodece"]},sidebar:"docs",previous:{title:"Supported Models",permalink:"/th/docs/supported-models"},next:{title:"Effector",permalink:"/th/docs/effector"}},s={},p=[{value:"Request definition",id:"request-definition",level:2},{value:"Policy Definition",id:"policy-definition",level:2},{value:"Policy Effect",id:"policy-effect",level:2},{value:"Matchers",id:"matchers",level:2},{value:"Order of expressions in matchers",id:"order-of-expressions-in-matchers",level:3},{value:"Multiple Section Types",id:"multiple-section-types",level:2},{value:"Special Grammar",id:"special-grammar",level:2},{value:"Expression Evaluator",id:"expression-evaluator",level:2}],c=e=>function(t){return console.warn("Component "+e+" was not imported, exported, or provided by MDXProvider as global scope"),(0,r.kt)("div",t)},m=c("Tabs"),d=c("TabItem"),u={toc:p};function h(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"A model configuration (CONF) should have at least four sections: ",(0,r.kt)("inlineCode",{parentName:"p"},"[request_definition]"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"[policy_definition]"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"[policy_effect]"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"[matchers]"),".")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"If a model uses Role-Based Access Control (RBAC), it should also include the ",(0,r.kt)("inlineCode",{parentName:"p"},"[role_definition]")," section.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"A model configuration (CONF) can contain comments. Comments start with the ",(0,r.kt)("inlineCode",{parentName:"p"},"#")," symbol, and everything after the ",(0,r.kt)("inlineCode",{parentName:"p"},"#")," symbol will be commented out."))),(0,r.kt)("h2",{id:"request-definition"},"Request definition"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"[request_definition]")," section defines the arguments in the ",(0,r.kt)("inlineCode",{parentName:"p"},"e.Enforce(...)")," function."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ini"},"[request_definition]\nr = sub, obj, act\n")),(0,r.kt)("p",null,"In this example, ",(0,r.kt)("inlineCode",{parentName:"p"},"sub"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"obj"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"act")," represent the classic access triple: the subject (accessing entity), the object (accessed resource), and the action (access method). However, you can customize your own request format. For example, you can use ",(0,r.kt)("inlineCode",{parentName:"p"},"sub, act")," if you don't need to specify a particular resource, or ",(0,r.kt)("inlineCode",{parentName:"p"},"sub, sub2, obj, act")," if you have two accessing entities."),(0,r.kt)("h2",{id:"policy-definition"},"Policy Definition"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"[policy_definition]")," is the definition for a policy. It defines the meaning of the policy. For example, we have the following model:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ini"},"[policy_definition]\np = sub, obj, act\np2 = sub, act\n")),(0,r.kt)("p",null,"And we have the following policy (if in a policy file):"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csv"},"p, alice, data1, read\np2, bob, write-all-objects\n")),(0,r.kt)("p",null,"Each line in a policy is called a policy rule. Each policy rule starts with a ",(0,r.kt)("inlineCode",{parentName:"p"},"policy type"),", such as ",(0,r.kt)("inlineCode",{parentName:"p"},"p")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"p2"),". It is used to match the policy definition if there are multiple definitions. The above policy shows the following binding. The binding can be used in the matcher."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-text"},"(alice, data1, read) -> (p.sub, p.obj, p.act)\n(bob, write-all-objects) -> (p2.sub, p2.act)\n")),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("p",{parentName:"admonition"},"The elements in a policy rule are always regarded as ",(0,r.kt)("inlineCode",{parentName:"p"},"strings"),". If you have any questions about this, please refer to the discussion at: ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/casbin/casbin/issues/113"},"https://github.com/casbin/casbin/issues/113"))),(0,r.kt)("h2",{id:"policy-effect"},"Policy Effect"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"[policy_effect]")," is the definition for the policy effect. It determines whether the access request should be approved if multiple policy rules match the request. For example, one rule permits and the other denies."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ini"},"[policy_effect]\ne = some(where (p.eft == allow))\n")),(0,r.kt)("p",null,"The above policy effect means that if there's any matched policy rule of ",(0,r.kt)("inlineCode",{parentName:"p"},"allow"),", the final effect is ",(0,r.kt)("inlineCode",{parentName:"p"},"allow")," (also known as allow-override). ",(0,r.kt)("inlineCode",{parentName:"p"},"p.eft")," is the effect for a policy, and it can be either ",(0,r.kt)("inlineCode",{parentName:"p"},"allow")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"deny"),". It is optional, and the default value is ",(0,r.kt)("inlineCode",{parentName:"p"},"allow"),". Since we didn't specify it above, it uses the default value."),(0,r.kt)("p",null,"Another example for the policy effect is:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ini"},"[policy_effect]\ne = !some(where (p.eft == deny))\n")),(0,r.kt)("p",null,"This means that if there are no matched policy rules of ",(0,r.kt)("inlineCode",{parentName:"p"},"deny"),", the final effect is ",(0,r.kt)("inlineCode",{parentName:"p"},"allow")," (also known as deny-override). ",(0,r.kt)("inlineCode",{parentName:"p"},"some")," means that there exists one matched policy rule. ",(0,r.kt)("inlineCode",{parentName:"p"},"any")," means that all matched policy rules (not used here). The policy effect can even be connected with logical expressions:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ini"},"[policy_effect]\ne = some(where (p.eft == allow)) && !some(where (p.eft == deny))\n")),(0,r.kt)("p",null,"This means that there must be at least one matched policy rule of ",(0,r.kt)("inlineCode",{parentName:"p"},"allow"),", and there cannot be any matched policy rule of ",(0,r.kt)("inlineCode",{parentName:"p"},"deny"),". Therefore, in this way, both allow and deny authorizations are supported, and the deny overrides."),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"Although we designed the syntax of the policy effect as above, the current implementations only use hard-coded policy effects. This is because we found that there isn't much need for that level of flexibility. So for now, you must use one of the built-in policy effects instead of customizing your own.")),(0,r.kt)("p",null,"The supported built-in policy effects are:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Policy Effect"),(0,r.kt)("th",{parentName:"tr",align:null},"Meaning"),(0,r.kt)("th",{parentName:"tr",align:null},"Example"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"some(where (p.eft == allow))"),(0,r.kt)("td",{parentName:"tr",align:null},"allow-override"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/docs/supported-models#examples"},"ACL, RBAC, etc."))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"!some(where (p.eft == deny))"),(0,r.kt)("td",{parentName:"tr",align:null},"deny-override"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/docs/supported-models#examples"},"Deny-override"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"some(where (p.eft == allow)) && !some(where (p.eft == deny))"),(0,r.kt)("td",{parentName:"tr",align:null},"allow-and-deny"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/docs/supported-models#examples"},"Allow-and-deny"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"priority(p.eft) ","|","|"," deny"),(0,r.kt)("td",{parentName:"tr",align:null},"priority"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/docs/supported-models#examples"},"Priority"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"subjectPriority(p.eft)"),(0,r.kt)("td",{parentName:"tr",align:null},"priority based on role"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/docs/supported-models#examples"},"Subject-Priority"))))),(0,r.kt)("h2",{id:"matchers"},"Matchers"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"[matchers]")," is the definition for policy matchers. The matchers are expressions that define how the policy rules are evaluated against the request."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ini"},"[matchers]\nm = r.sub == p.sub && r.obj == p.obj && r.act == p.act\n")),(0,r.kt)("p",null,"The above matcher is the simplest and means that the subject, object, and action in a request should match the ones in a policy rule."),(0,r.kt)("p",null,"Arithmetic operators like ",(0,r.kt)("inlineCode",{parentName:"p"},"+, -, *, /")," and logical operators like ",(0,r.kt)("inlineCode",{parentName:"p"},"&&, ||, !")," can be used in matchers."),(0,r.kt)("h3",{id:"order-of-expressions-in-matchers"},"Order of expressions in matchers"),(0,r.kt)("p",null,"The order of expressions can greatly affect performance. Take a look at the following example for more details:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},'const rbac_models = `\n[request_definition]\nr = sub, obj, act\n\n[policy_definition]\np = sub, obj, act\n\n[role_definition]\ng = _, _\n\n[policy_effect]\ne = some(where (p.eft == allow))\n\n[matchers]\nm = g(r.sub, p.sub) && r.obj == p.obj && r.act == p.act\n`\n\nfunc TestManyRoles(t *testing.T) {\n\n    m, _ := model.NewModelFromString(rbac_models)\n    e, _ := NewEnforcer(m, false)\n\n    roles := []string{"admin", "manager", "developer", "tester"}\n\n    // 2500 projects\n    for nbPrj := 1; nbPrj < 2500; nbPrj++ {\n        // 4 objects and 1 role per object (so 4 roles)\n        for _, role := range roles {\n            roleDB := fmt.Sprintf("%s_project:%d", role, nbPrj)\n            objectDB := fmt.Sprintf("/projects/%d", nbPrj)\n            e.AddPolicy(roleDB, objectDB, "GET")\n        }\n        jasmineRole := fmt.Sprintf("%s_project:%d", roles[1], nbPrj)\n        e.AddGroupingPolicy("jasmine", jasmineRole)\n    }\n\n    e.AddGroupingPolicy("abu", "manager_project:1")\n    e.AddGroupingPolicy("abu", "manager_project:2499")\n\n    // With same number of policies\n    // User \'abu\' has only two roles\n    // User \'jasmine\' has many roles (1 role per policy, here 2500 roles)\n\n    request := func(subject, object, action string) {\n        t0 := time.Now()\n        resp, _ := e.Enforce(subject, object, action)\n        tElapse := time.Since(t0)\n        t.Logf("RESPONSE %-10s %s\\t %s : %5v IN: %+v", subject, object, action, resp, tElapse)\n        if tElapse > time.Millisecond*100 {\n            t.Errorf("More than 100 milliseconds for %s %s %s : %+v", subject, object, action, tElapse)\n        }\n    }\n\n    request("abu", "/projects/1", "GET")        // really fast because only 2 roles in all policies and at the beginning of the casbin_rule table\n    request("abu", "/projects/2499", "GET")     // fast because only 2 roles in all policies\n    request("jasmine", "/projects/1", "GET")    // really fast at the beginning of the casbin_rule table\n\n    request("jasmine", "/projects/2499", "GET") // slow and fails the only 1st time   <<<< pb here\n    request("jasmine", "/projects/2499", "GET") // fast maybe due to internal cache mechanism\n\n    // same issue with non-existing roles\n    // request("jasmine", "/projects/999999", "GET") // slow fails the only 1st time   <<<< pb here\n    // request("jasmine", "/projects/999999", "GET") // fast maybe due to internal cache mechanism\n}\n')),(0,r.kt)("p",null,"The enforcement time may be very long, up to 6 seconds."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"go test -run ^TestManyRoles$ github.com/casbin/casbin/v2 -v\n\n=== RUN   TestManyRoles\n    rbac_api_test.go:598: RESPONSE abu        /projects/1        GET :  true IN: 438.379\xb5s\n    rbac_api_test.go:598: RESPONSE abu        /projects/2499     GET :  true IN: 39.005173ms\n    rbac_api_test.go:598: RESPONSE jasmine    /projects/1        GET :  true IN: 1.774319ms\n    rbac_api_test.go:598: RESPONSE jasmine    /projects/2499     GET :  true IN: 6.164071648s\n    rbac_api_test.go:600: More than 100 milliseconds for jasmine /projects/2499 GET : 6.164071648s\n    rbac_api_test.go:598: RESPONSE jasmine    /projects/2499     GET :  true IN: 12.164122ms\n--- FAIL: TestManyRoles (6.24s)\nFAIL\nFAIL    github.com/casbin/casbin/v2     6.244s\nFAIL\n")),(0,r.kt)("p",null,"However, if we adjust the order of the expressions in matchers and put more time-consuming expressions like functions behind, the execution time will be very short."),(0,r.kt)("p",null,"Changing the order of expressions in matchers in the above example to:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ini"},"[matchers]\nm = r.obj == p.obj && g(r.sub, p.sub) && r.act == p.act\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"go test -run ^TestManyRoles$ github.com/casbin/casbin/v2 -v\n=== RUN   TestManyRoles\n    rbac_api_test.go:599: RESPONSE abu        /projects/1        GET :  true IN: 786.635\xb5s\n    rbac_api_test.go:599: RESPONSE abu        /projects/2499     GET :  true IN: 4.933064ms\n    rbac_api_test.go:599: RESPONSE jasmine    /projects/1        GET :  true IN: 2.908534ms\n    rbac_api_test.go:599: RESPONSE jasmine    /projects/2499     GET :  true IN: 7.292963ms\n    rbac_api_test.go:599: RESPONSE jasmine    /projects/2499     GET :  true IN: 6.168307ms\n--- PASS: TestManyRoles (0.05s)\nPASS\nok      github.com/casbin/casbin/v2     0.053s\n")),(0,r.kt)("h2",{id:"multiple-section-types"},"Multiple Section Types"),(0,r.kt)("p",null,"If you need multiple policy definitions or multiple matchers, you can use ",(0,r.kt)("inlineCode",{parentName:"p"},"p2")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"m2")," as examples. In fact, all four sections mentioned above can use multiple types, and the syntax is ",(0,r.kt)("inlineCode",{parentName:"p"},"r")," followed by a number, such as ",(0,r.kt)("inlineCode",{parentName:"p"},"r2")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"e2"),". By default, these four sections should correspond one-to-one. For example, your ",(0,r.kt)("inlineCode",{parentName:"p"},"r2")," section will only use the ",(0,r.kt)("inlineCode",{parentName:"p"},"m2")," matcher to match ",(0,r.kt)("inlineCode",{parentName:"p"},"p2")," policies."),(0,r.kt)("p",null,"You can pass an ",(0,r.kt)("inlineCode",{parentName:"p"},"EnforceContext")," as the first parameter of the ",(0,r.kt)("inlineCode",{parentName:"p"},"enforce")," method to specify the types. The ",(0,r.kt)("inlineCode",{parentName:"p"},"EnforceContext")," is defined as follows:"),(0,r.kt)(m,{groupId:"langs",mdxType:"Tabs"},(0,r.kt)(d,{value:"Go",label:"Go",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},'EnforceContext{"r2","p2","e2","m2"}\ntype EnforceContext struct {\n    RType string\n    PType string\n    EType string\n    MType string\n}\n'))),(0,r.kt)(d,{value:"Node.js",label:"Node.js",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"const enforceContext = new EnforceContext('r2', 'p2', 'e2', 'm2');\nclass EnforceContext {\n  constructor(rType, pType, eType, mType) {\n    this.pType = pType;\n    this.eType = eType;\n    this.mType = mType;\n    this.rType = rType;\n  }\n}\n"))),(0,r.kt)(d,{value:"Java",label:"Java",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'EnforceContext enforceContext = new EnforceContext("2");\npublic class EnforceContext {\n    private String pType;\n    private String eType;\n    private String mType;\n    private String rType;\n    public EnforceContext(String suffix) {\n      this.pType = "p" + suffix;\n      this.eType = "e" + suffix;\n      this.mType = "m" + suffix;\n      this.rType = "r" + suffix;\n    }\n}\n')))),(0,r.kt)("p",null,"Here is an example usage. Please refer to the ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/casbin/casbin/blob/master/examples/multiple_policy_definitions_model.conf"},"model")," and ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/casbin/casbin/blob/master/examples/multiple_policy_definitions_policy.csv"},"policy"),". The request is as follows:"),(0,r.kt)(m,{groupId:"langs",mdxType:"Tabs"},(0,r.kt)(d,{value:"Go",label:"Go",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},'// Pass in a suffix as a parameter to NewEnforceContext, such as 2 or 3, and it will create r2, p2, etc.\nenforceContext := NewEnforceContext("2")\n// You can also specify a certain type individually\nenforceContext.EType = "e"\n// Don\'t pass in EnforceContext; the default is r, p, e, m\ne.Enforce("alice", "data2", "read")        // true\n// Pass in EnforceContext\ne.Enforce(enforceContext, struct{ Age int }{Age: 70}, "/data1", "read")        //false\ne.Enforce(enforceContext, struct{ Age int }{Age: 30}, "/data1", "read")        //true\n'))),(0,r.kt)(d,{value:"Node.js",label:"Node.js",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},'// Pass in a suffix as a parameter to NewEnforceContext, such as 2 or 3, and it will create r2, p2, etc.\nconst enforceContext = new NewEnforceContext(\'2\');\n\n// You can also specify a certain type individually\nenforceContext.eType = "e"\n\n// Don\'t pass in EnforceContext; the default is r, p, e, m\ne.Enforce("alice", "data2", "read")        // true\n\n// Pass in EnforceContext\ne.Enforce(enforceContext, {Age: 70}, "/data1", "read")        //false\ne.Enforce(enforceContext, {Age: 30}, "/data1", "read")        //true\n'))),(0,r.kt)(d,{value:"Java",label:"Java",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'// Pass in a suffix as a parameter to NewEnforceContext, such as 2 or 3, and it will create r2, p2, etc.\nEnforceContext enforceContext = new EnforceContext("2");\n// You can also specify a certain type individually\nenforceContext.seteType("e");\n// Don\'t pass in EnforceContext; the default is r, p, e, m\ne.enforce("alice", "data2", "read");  // true\n// Pass in EnforceContext\n// TestEvalRule is located in https://github.com/casbin/jcasbin/blob/master/src/test/java/org/casbin/jcasbin/main/AbacAPIUnitTest.java#L56\ne.enforce(enforceContext, new AbacAPIUnitTest.TestEvalRule("alice", 70), "/data1", "read"); // false\ne.enforce(enforceContext, new AbacAPIUnitTest.TestEvalRule("alice", 30), "/data1", "read"); // true\n')))),(0,r.kt)("h2",{id:"special-grammar"},"Special Grammar"),(0,r.kt)("p",null,'You could also use the "in" operator, which is the only operator with a text name. This operator checks the array on the right-hand side to see if it contains a value that is equal to the value on the left side. Equality is determined by using the == operator, and this library does not check the types between the values. As long as two values can be cast to interface{} and can still be checked for equality with ==, they will act as expected. Note that you can use a parameter for the array, but it must be an ',"[","]interface{}."),(0,r.kt)("p",null,"Also refer to ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/casbin/casbin/blob/277c1a2b85698272f764d71a94d2595a8d425915/examples/rbac_model_matcher_using_in_op.conf"},"rbac","_","model","_","matcher","_","using","_","in","_","op"),", ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/casbin/casbin/blob/277c1a2b85698272f764d71a94d2595a8d425915/examples/keyget2_model.conf"},"keyget2","_","model"),", and ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/casbin/casbin/blob/277c1a2b85698272f764d71a94d2595a8d425915/examples/keyget_model.conf"},"keyget","_","model"),"."),(0,r.kt)("p",null,"Example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ini"},"[request_definition]\nr = sub, obj\n...\n[matchers]\nm = r.sub.Name in (r.obj.Admins)\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},'e.Enforce(Sub{Name: "alice"}, Obj{Name: "a book", Admins: []interface{}{"alice", "bob"}})\n')),(0,r.kt)("h2",{id:"expression-evaluator"},"Expression Evaluator"),(0,r.kt)("p",null,"The matcher evaluation in Casbin is implemented by expression evaluators in each language. Casbin integrates their powers to provide the unified PERM language. In addition to the model syntax provided here, these expression evaluators may offer extra functionality that might not be supported by another language or implementation. Please be cautious when using this functionality."),(0,r.kt)("p",null,"The expression evaluators used by each Casbin implementation are as follows:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Implementation"),(0,r.kt)("th",{parentName:"tr",align:null},"Language"),(0,r.kt)("th",{parentName:"tr",align:null},"Expression Evaluator"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Casbin"),(0,r.kt)("td",{parentName:"tr",align:null},"Golang"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"https://github.com/Knetic/govaluate"},"https://github.com/Knetic/govaluate"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"jCasbin"),(0,r.kt)("td",{parentName:"tr",align:null},"Java"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"https://github.com/killme2008/aviator"},"https://github.com/killme2008/aviator"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Node-Casbin"),(0,r.kt)("td",{parentName:"tr",align:null},"Node.js"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"https://github.com/donmccurdy/expression-eval"},"https://github.com/donmccurdy/expression-eval"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"PHP-Casbin"),(0,r.kt)("td",{parentName:"tr",align:null},"PHP"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"https://github.com/symfony/expression-language"},"https://github.com/symfony/expression-language"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"PyCasbin"),(0,r.kt)("td",{parentName:"tr",align:null},"Python"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"https://github.com/danthedeckie/simpleeval"},"https://github.com/danthedeckie/simpleeval"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Casbin.NET"),(0,r.kt)("td",{parentName:"tr",align:null},"C#"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"https://github.com/davideicardi/DynamicExpresso"},"https://github.com/davideicardi/DynamicExpresso"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Casbin4D"),(0,r.kt)("td",{parentName:"tr",align:null},"Delphi"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"https://github.com/casbin4d/Casbin4D/tree/master/SourceCode/Common/Third%20Party/TExpressionParser"},"https://github.com/casbin4d/Casbin4D/tree/master/SourceCode/Common/Third%20Party/TExpressionParser"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"casbin-rs"),(0,r.kt)("td",{parentName:"tr",align:null},"Rust"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"https://github.com/jonathandturner/rhai"},"https://github.com/jonathandturner/rhai"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"casbin-cpp"),(0,r.kt)("td",{parentName:"tr",align:null},"C++"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"https://github.com/ArashPartow/exprtk"},"https://github.com/ArashPartow/exprtk"))))),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"If you encounter a performance issue with Casbin, it is likely caused by the low efficiency of the expression evaluator. You can address the issue to Casbin or the expression evaluator directly for advice on speeding up the performance. For more details, please refer to the ",(0,r.kt)("a",{parentName:"p",href:"/docs/benchmark"},"Benchmarks")," section.")))}h.isMDXComponent=!0}}]);