"use strict";(globalThis.webpackChunkcasbin_website_v2=globalThis.webpackChunkcasbin_website_v2||[]).push([[1367],{4814(e,i,t){t.r(i),t.d(i,{assets:()=>a,contentTitle:()=>c,default:()=>p,frontMatter:()=>r,metadata:()=>o,toc:()=>l});const o=JSON.parse('{"id":"policy-subset-loading","title":"Loading Policy Subsets","description":"T\u1ea3i ch\xednh s\xe1ch \u0111\xe3 l\u1ecdc","source":"@site/i18n/vi/docusaurus-plugin-content-docs/current/PolicySubsetLoading.mdx","sourceDirName":".","slug":"/policy-subset-loading","permalink":"/vi/docs/policy-subset-loading","draft":false,"unlisted":false,"editUrl":"https://github.com/casbin/casbin-website-v2/edit/master/docs/PolicySubsetLoading.mdx","tags":[],"version":"current","frontMatter":{"id":"policy-subset-loading","title":"Loading Policy Subsets","description":"T\u1ea3i ch\xednh s\xe1ch \u0111\xe3 l\u1ecdc","keywords":["filtered policies","policy subset","performance optimization"],"authors":["hsluoyz"]},"sidebar":"docs","previous":{"title":"Policy Storage","permalink":"/vi/docs/policy-storage"},"next":{"title":"Use Cases","permalink":"/vi/docs/category/use-cases"}}');var n=t(4848),s=t(8453);const r={id:"policy-subset-loading",title:"Loading Policy Subsets",description:"T\u1ea3i ch\xednh s\xe1ch \u0111\xe3 l\u1ecdc",keywords:["filtered policies","policy subset","performance optimization"],authors:["hsluoyz"]},c=void 0,a={},l=[];function d(e){const i={a:"a",code:"code",p:"p",pre:"pre",strong:"strong",...(0,s.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(i.p,{children:["Some ",(0,n.jsx)(i.a,{href:"/docs/adapters",children:"adapters"})," support ",(0,n.jsx)(i.strong,{children:"filtered policy loading"}),": only a subset of policies is loaded from storage according to a filter. That reduces memory and speed in large or multi-tenant setups where loading the full policy set is impractical."]}),"\n",(0,n.jsxs)(i.p,{children:["Call ",(0,n.jsx)(i.code,{children:"LoadFilteredPolicy(filter)"})," with a supported adapter. The filter shape is adapter-specific. When using filtered loading, ",(0,n.jsx)(i.code,{children:"SavePolicy()"})," is disabled so you don\u2019t overwrite the full policy by mistake."]}),"\n",(0,n.jsxs)(i.p,{children:["Example: filtered file adapter with an RBAC-with-domains model. The filter loads only policies for ",(0,n.jsx)(i.code,{children:"domain1"}),":"]}),"\n",(0,n.jsx)(i.pre,{children:(0,n.jsx)(i.code,{className:"language-go",children:'import (\n    "github.com/casbin/casbin/v3"\n    fileadapter "github.com/casbin/casbin/v3/persist/file-adapter"\n)\n\nenforcer, _ := casbin.NewEnforcer()\n\nadapter := fileadapter.NewFilteredAdapter("examples/rbac_with_domains_policy.csv")\nenforcer.InitWithAdapter("examples/rbac_with_domains_model.conf", adapter)\n\nfilter := &fileadapter.Filter{\n    P: []string{"", "domain1"},\n    G: []string{"", "", "domain1"},\n}\nenforcer.LoadFilteredPolicy(filter)\n\n// Only policies for "domain1" are loaded.\n'})}),"\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.code,{children:"LoadIncrementalFilteredPolicy(filter)"})," works like ",(0,n.jsx)(i.code,{children:"LoadFilteredPolicy"})," but ",(0,n.jsx)(i.strong,{children:"adds"})," the filtered policies to the current in-memory policy instead of replacing it. You can combine several filtered loads (e.g. per tenant) into one enforcer."]})]})}function p(e={}){const{wrapper:i}={...(0,s.R)(),...e.components};return i?(0,n.jsx)(i,{...e,children:(0,n.jsx)(d,{...e})}):d(e)}},8453(e,i,t){t.d(i,{R:()=>r,x:()=>c});var o=t(6540);const n={},s=o.createContext(n);function r(e){const i=o.useContext(s);return o.useMemo(function(){return"function"==typeof e?e(i):{...i,...e}},[i,e])}function c(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:r(e.components),o.createElement(s.Provider,{value:i},e.children)}}}]);