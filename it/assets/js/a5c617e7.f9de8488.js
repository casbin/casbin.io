"use strict";(globalThis.webpackChunkcasbin_website_v2=globalThis.webpackChunkcasbin_website_v2||[]).push([[3170],{567(e,i,n){n.r(i),n.d(i,{assets:()=>l,contentTitle:()=>r,default:()=>u,frontMatter:()=>s,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"how-it-works","title":"How It Works","description":"Come Funziona Casbin","source":"@site/i18n/it/docusaurus-plugin-content-docs/current/HowItWorks.mdx","sourceDirName":".","slug":"/how-it-works","permalink":"/it/docs/how-it-works","draft":false,"unlisted":false,"editUrl":"https://github.com/casbin/casbin-website-v2/edit/master/docs/HowItWorks.mdx","tags":[],"version":"current","frontMatter":{"id":"how-it-works","title":"How It Works","description":"Come Funziona Casbin","keywords":["PERM","request","policy","matcher","effect"],"authors":["nodece"]},"sidebar":"docs","previous":{"title":"Get Started","permalink":"/it/docs/get-started"},"next":{"title":"Tutorials","permalink":"/it/docs/tutorials"}}');var t=n(4848),a=n(8453);const s={id:"how-it-works",title:"How It Works",description:"Come Funziona Casbin",keywords:["PERM","request","policy","matcher","effect"],authors:["nodece"]},r=void 0,l={},c=[{value:"Request",id:"request",level:3},{value:"Policy",id:"policy",level:3},{value:"Matcher",id:"matcher",level:3},{value:"Effect",id:"effect",level:3}];function d(e){const i={a:"a",code:"code",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(i.p,{children:["In Casbin, un modello di controllo degli accessi \xe8 astratto in un file CONF basato sul ",(0,t.jsx)(i.strong,{children:"metamodello PERM (Policy, Effect, Request, Matchers)"}),". Cambiare o aggiornare il meccanismo di autorizzazione per un progetto \xe8 semplice come modificare una configurazione. Puoi personalizzare il tuo modello di controllo degli accessi combinando i modelli disponibili. Ad esempio, puoi combinare ruoli RBAC e attributi ABAC all'interno di un singolo modello e condividere un insieme di regole di policy."]}),"\n",(0,t.jsx)(i.p,{children:"Il modello PERM \xe8 composto da quattro fondamenti: Policy, Effect, Request e Matchers. Questi fondamenti descrivono la relazione tra risorse e utenti."}),"\n",(0,t.jsx)(i.h3,{id:"request",children:"Request"}),"\n",(0,t.jsx)(i.p,{children:"Definisce i parametri della richiesta. Una richiesta di base \xe8 un oggetto tupla, che richiede almeno un soggetto (entit\xe0 a cui si accede), un oggetto (risorsa a cui si accede) e un'azione (metodo di accesso)."}),"\n",(0,t.jsx)(i.p,{children:"Ad esempio, una definizione di richiesta potrebbe essere simile a questa:"}),"\n",(0,t.jsx)(i.p,{children:"Questa definizione specifica i nomi dei parametri e l'ordine richiesto dalla funzione di corrispondenza del controllo di accesso."}),"\n",(0,t.jsx)(i.h3,{id:"policy",children:"Policy"}),"\n",(0,t.jsx)(i.p,{children:"Definisce il modello per la strategia di accesso. Specifica il nome e l'ordine dei campi nel documento della regola della Politica."}),"\n",(0,t.jsx)(i.p,{children:"Ad esempio:"}),"\n",(0,t.jsx)(i.p,{children:"Nota: Se eft (risultato della politica) non \xe8 definito, il campo del risultato nel file della politica non verr\xe0 letto e il risultato della politica corrispondente sar\xe0 consentito di default."}),"\n",(0,t.jsx)(i.h3,{id:"matcher",children:"Matcher"}),"\n",(0,t.jsx)(i.p,{children:"Definisce le regole di corrispondenza per la Richiesta e la Policy."}),"\n",(0,t.jsxs)(i.p,{children:["Ad esempio: ",(0,t.jsx)(i.code,{children:"m = r.sub == p.sub && r.act == p.act && r.obj == p.obj"})," Il risultato della strategia verr\xe0 salvato in ",(0,t.jsx)(i.code,{children:"p.eft"}),"."]}),"\n",(0,t.jsx)(i.h3,{id:"effect",children:"Effect"}),"\n",(0,t.jsx)(i.p,{children:"Esegue una combinazione logica di giudizio sui risultati di corrispondenza dei Matcher."}),"\n",(0,t.jsxs)(i.p,{children:["Ad esempio: ",(0,t.jsx)(i.code,{children:"e = some(where(p.eft == allow))"})]}),"\n",(0,t.jsxs)(i.p,{children:["Questa affermazione significa che se il risultato della strategia di corrispondenza ",(0,t.jsx)(i.code,{children:"p.eft"})," ha il risultato di (alcuni) allow, allora il risultato finale \xe8 vero."]}),"\n",(0,t.jsx)(i.p,{children:"Diamo un'occhiata a un altro esempio:"}),"\n",(0,t.jsx)(i.p,{children:(0,t.jsx)(i.code,{children:"e = some(where (p.eft == allow)) && !some(where (p.eft == deny))"})}),"\n",(0,t.jsx)(i.p,{children:"Il significato logico di questa combinazione di esempio \xe8: se esiste una strategia che corrisponde al risultato di allow e nessuna strategia che corrisponde al risultato di deny, il risultato \xe8 true. In altre parole, \xe8 true quando tutte le strategie corrispondenti sono allow. Se c'\xe8 qualche deny, entrambe sono false (pi\xf9 semplicemente, quando allow e deny esistono contemporaneamente, deny ha la precedenza)."}),"\n",(0,t.jsx)(i.p,{children:"Il modello pi\xf9 basilare e semplice in Casbin \xe8 ACL. Il modello CONF per ACL \xe8 il seguente:"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-ini",children:"# Request definition\n[request_definition]\nr = sub, obj, act\n\n# Policy definition\n[policy_definition]\np = sub, obj, act\n\n# Policy effect\n[policy_effect]\ne = some(where (p.eft == allow))\n\n# Matchers\n[matchers]\nm = r.sub == p.sub && r.obj == p.obj && r.act == p.act\n\n"})}),"\n",(0,t.jsx)(i.p,{children:"Un esempio di policy per il modello ACL \xe8:"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-csv",children:"p, alice, data1, read\np, bob, data2, write\n"})}),"\n",(0,t.jsx)(i.p,{children:"Ci\xf2 significa:"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"alice pu\xf2 leggere data1"}),"\n",(0,t.jsx)(i.li,{children:"bob pu\xf2 scrivere data2"}),"\n"]}),"\n",(0,t.jsx)(i.p,{children:"Supportiamo anche la modalit\xe0 multi-linea aggiungendo '' alla fine:"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-ini",children:"# Matchers\n[matchers]\nm = r.sub == p.sub && r.obj == p.obj \\\n  && r.act == p.act\n"})}),"\n",(0,t.jsxs)(i.p,{children:["Inoltre, se stai utilizzando ABAC, puoi provare l'operatore 'in' come mostrato nell'esempio seguente per l'edizione ",(0,t.jsx)(i.strong,{children:"golang"})," di Casbin (jCasbin e Node-Casbin non sono ancora supportati):"]}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-ini",children:"# Matchers\n[matchers]\nm = r.obj == p.obj && r.act == p.act || r.obj in ('data2', 'data3')\n"})}),"\n",(0,t.jsxs)(i.p,{children:["Ma ",(0,t.jsx)(i.strong,{children:"DEVI"})," assicurarti che la lunghezza dell'array sia ",(0,t.jsx)(i.strong,{children:"MAGGIORE"})," di ",(0,t.jsx)(i.strong,{children:"1"}),", altrimenti causer\xe0 un panico."]}),"\n",(0,t.jsxs)(i.p,{children:["For more operators, you may take a look at ",(0,t.jsx)(i.a,{href:"https://github.com/casbin/govaluate",children:"govaluate"}),"."]})]})}function u(e={}){const{wrapper:i}={...(0,a.R)(),...e.components};return i?(0,t.jsx)(i,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453(e,i,n){n.d(i,{R:()=>s,x:()=>r});var o=n(6540);const t={},a=o.createContext(t);function s(e){const i=o.useContext(a);return o.useMemo(function(){return"function"==typeof e?e(i):{...i,...e}},[i,e])}function r(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:s(e.components),o.createElement(a.Provider,{value:i},e.children)}}}]);