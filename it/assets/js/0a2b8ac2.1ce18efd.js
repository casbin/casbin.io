"use strict";(self.webpackChunkcasbin_website_v2=self.webpackChunkcasbin_website_v2||[]).push([[3674],{2549:e=>{e.exports=JSON.parse('{"blogPosts":[{"id":"casbin-2025-ai-agent-era","metadata":{"permalink":"/it/blog/casbin-2025-ai-agent-era","editUrl":"https://github.com/casbin/casbin-website-v2/edit/master/i18n/it/docusaurus-plugin-content-blog/2025-12-11-casbin-2025-ai-agent-era.md","source":"@site/i18n/it/docusaurus-plugin-content-blog/2025-12-11-casbin-2025-ai-agent-era.md","title":"Casbin in 2025: Authorization for the AI Agent Era","description":"2024 was the year AI agents went from demos to production. With the Model Context Protocol (MCP) gaining adoption from Google, OpenAI, Microsoft, and countless others, we\'re seeing a fundamental shift in how applications interact with external services. And with that shift comes a whole new set of authorization challenges that we at Casbin have been thinking about.","date":"2025-12-11T00:00:00.000Z","formattedDate":"11 dicembre 2025","tags":[{"label":"casbin","permalink":"/it/blog/tags/casbin"},{"label":"roadmap","permalink":"/it/blog/tags/roadmap"},{"label":"AI","permalink":"/it/blog/tags/ai"},{"label":"MCP","permalink":"/it/blog/tags/mcp"},{"label":"edge-computing","permalink":"/it/blog/tags/edge-computing"},{"label":"LLM","permalink":"/it/blog/tags/llm"}],"readingTime":4.615,"hasTruncateMarker":true,"authors":[{"name":"Yang Luo","url":"http://github.com/hsluoyz","imageURL":"https://avatars.githubusercontent.com/hsluoyz"}],"frontMatter":{"title":"Casbin in 2025: Authorization for the AI Agent Era","slug":"casbin-2025-ai-agent-era","author":"Yang Luo","authorURL":"http://github.com/hsluoyz","authorImageURL":"https://avatars.githubusercontent.com/hsluoyz","tags":["casbin","roadmap","AI","MCP","edge-computing","LLM"]},"nextItem":{"title":"Understanding How Casbin Matching Works in Detail","permalink":"/it/blog/2023/12/08/understanding-casbin-matching-in-detail"}},"content":"2024 was the year AI agents went from demos to production. With the Model Context Protocol (MCP) gaining adoption from Google, OpenAI, Microsoft, and countless others, we\'re seeing a fundamental shift in how applications interact with external services. And with that shift comes a whole new set of authorization challenges that we at Casbin have been thinking about.\\n\\n\x3c!--truncate--\x3e\\n\\n## The World Has Changed\\n\\nWhen we started Casbin back in 2017, the typical authorization scenario was straightforward: a user makes a request, we check if they have permission, done. Today? An AI agent might be acting on behalf of a user, calling multiple MCP servers, each with their own tool permissions, and the whole thing needs to happen in milliseconds at the edge.\\n\\nThe MCP specification now explicitly classifies MCP servers as OAuth 2.0 Resource Servers (as of the June 2025 update), requiring fine-grained scopes like `mcp:tools:weather` or `mcp:resources:customer-data:read`. This is exactly the kind of granular permission model Casbin was built for - but the integration story needs work.\\n\\n## What We\'re Working On\\n\\n### MCP Server Authorization\\n\\nThis is probably the most exciting area for us right now. When an AI agent calls an MCP server, that server needs to decide: can this agent, acting on behalf of this user, invoke this specific tool with these parameters?\\n\\nTraditional RBAC falls short here. You need something more like ABAC - checking not just \\"is alice an admin\\" but \\"is this agent authorized to access customer data for alice\'s region during business hours.\\" We\'re exploring how Casbin\'s policy model can express these constraints naturally.\\n\\nThe challenge is that MCP servers need to make these decisions fast. Really fast. We\'re looking at lightweight policy evaluation that can run in the MCP server process itself, rather than making network calls to a separate authorization service.\\n\\n### Edge-First Authorization\\n\\nCloudflare Workers, Deno Deploy, Vercel Edge Functions - the edge computing space has exploded. In 2025, sub-50ms response times are table stakes, and you can\'t afford to add 100ms for an authorization check to some central server.\\n\\nThis is pushing us to think differently about how Casbin works. Can we compile policies to WebAssembly and run them directly in V8 isolates? Can we do smart policy caching at the edge while maintaining consistency? These are hard problems, and we don\'t have all the answers yet, but it\'s where things are heading.\\n\\nWe\'re particularly interested in the Cloudflare Workers ecosystem - they\'ve built out a whole platform for MCP servers with built-in OAuth support. A native Casbin integration there could be powerful.\\n\\n### RAG Pipeline Authorization\\n\\nHere\'s something that keeps coming up: companies building RAG systems where the LLM needs access to internal documents, but different users should see different documents in their responses.\\n\\nThe OWASP Top 10 for LLM Applications 2025 lists \\"Sensitive Information Disclosure\\" as a major risk. The solution isn\'t just filtering outputs - it\'s ensuring the LLM never sees documents the user shouldn\'t have access to in the first place.\\n\\nThis means authorization checks need to happen at the vector store query level. We\'re thinking about how Casbin policies can translate into metadata filters for vector databases - essentially, turning a permission check into a WHERE clause that gets pushed down to the retrieval layer.\\n\\n### Multi-Agent Scenarios\\n\\nWhen you have multiple AI agents collaborating - think a coding agent that calls a deployment agent that calls a monitoring agent - permission delegation gets tricky. Each agent in the chain might have different capabilities, and you need to track the full chain of custody.\\n\\nThe OAuth On-Behalf-Of (OBO) flow handles some of this, but the authorization logic for \\"can agent B do X on behalf of agent A on behalf of user alice\\" needs a proper model. Casbin\'s support for role hierarchies and domain-based RBAC could extend naturally to agent hierarchies, but we need to think through the semantics carefully.\\n\\n## The Traditional Roadmap Stuff\\n\\nOf course, we\'re not abandoning the basics. Some practical things on our list:\\n\\n**Language implementations catching up** - SwiftCasbin and Lua-Casbin are still behind on features compared to the Go and Node.js versions. The `in` operator, WatcherEx, better caching for the `g` function - these need to be consistent everywhere.\\n\\n**New framework middlewares** - go-zero has been requested repeatedly. Poem for Rust is gaining traction. Play Framework for Java has been on the wishlist forever.\\n\\n**Performance work** - As policies get more complex for these new use cases, evaluation speed matters more. We need better benchmarking, profiling, and optimization across all implementations.\\n\\n## What We Don\'t Know Yet\\n\\nHonestly, the AI agent authorization space is moving so fast that we\'re learning as we go. Some open questions:\\n\\n- Should Casbin have first-class primitives for \\"agent identity\\" vs \\"user identity\\"?\\n- How do you handle authorization for tools that are dynamically discovered via MCP?\\n- What\'s the right caching strategy when policies might depend on real-time context?\\n\\nIf you\'re building in this space and running into authorization problems, we want to hear about it. The best features come from real use cases.\\n\\n## Getting Involved\\n\\nWe\'ve been a GSoC organization for years, and these AI-related projects are exactly the kind of thing that makes for interesting summer projects. But you don\'t need to wait for GSoC - if any of this sounds interesting, come chat with us on Discord or open an issue on GitHub.\\n\\nThe next few years are going to be wild for authorization. The problems are harder, but also more interesting. We\'re excited to figure them out together."},{"id":"/2023/12/08/understanding-casbin-matching-in-detail","metadata":{"permalink":"/it/blog/2023/12/08/understanding-casbin-matching-in-detail","editUrl":"https://github.com/casbin/casbin-website-v2/edit/master/i18n/it/docusaurus-plugin-content-blog/2023-12-08-understanding-casbin-matching-in-detail.md","source":"@site/i18n/it/docusaurus-plugin-content-blog/2023-12-08-understanding-casbin-matching-in-detail.md","title":"Understanding How Casbin Matching Works in Detail","description":"In this post, I will explain the design and implementation of RBAC using the Casbin library. For a SaaS platform dealing with multiple resource hierarchies and roles that inherit permissions from higher levels, Casbin provides a performant alternative to consider.","date":"2023-12-08T00:00:00.000Z","formattedDate":"8 dicembre 2023","tags":[],"readingTime":6.96,"hasTruncateMarker":false,"authors":[{"name":"Aravinda Kumar","url":"http://github.com/aravindarc","imageURL":"https://avatars.githubusercontent.com/aravindarc"}],"frontMatter":{"title":"Understanding How Casbin Matching Works in Detail","author":"Aravinda Kumar","authorURL":"http://github.com/aravindarc","authorImageURL":"https://avatars.githubusercontent.com/aravindarc"},"prevItem":{"title":"Casbin in 2025: Authorization for the AI Agent Era","permalink":"/it/blog/casbin-2025-ai-agent-era"},"nextItem":{"title":"Autorizzazione in APISIX utilizzando Casbin","permalink":"/it/blog/2021/08/19/apisix-casbin-authorization"}},"content":"In this post, I will explain the design and implementation of RBAC using the [Casbin](https://casbin.org/) library. For a SaaS platform dealing with multiple resource hierarchies and roles that inherit permissions from higher levels, Casbin provides a performant alternative to consider.\\n\\n## Introduction to RBAC\\n\\nRBAC is a method of restricting access to resources based on the roles that individuals hold. To better understand how hierarchical RBAC works, let\'s take a look at Azure\'s RBAC system in the next section and then attempt to implement a similar system.\\n\\n## Understanding Azure\'s Hierarchical RBAC\\n\\n![Azure Hierarchy](https://learn.microsoft.com/en-us/azure/cloud-adoption-framework/ready/azure-setup-guide/media/organize-resources/scope-levels.png)\\n\\nThere is a role called **Owner** for all resources in Azure. Suppose if I have the **Owner** role assigned to me at the\\nsubscription level, that means I am the **Owner** of all the resource groups and resources under that subscription. If I have\\n**Owner** at the resource group level, then I am the **Owner** of all the resources under that resource group.\\n\\nThis image shows that I have **Owner** access at the subscription level. ![Subscription Owner](/img/tutorial/subscription-owner.png)\\n\\nWhen I check the IAM of a Resource Group under this Subscription, you can see that I have inherited **Owner** access from the\\nsubscription. ![RG Owner](/img/tutorial/rg-owner.png)\\n\\nSo, this is how Azure\'s RBAC is hierarchical. Most enterprise software uses hierarchical RBAC because of the hierarchical\\nnature of the resource levels. In this tutorial, we\'ll try to implement a similar system using Casbin.\\n\\n## How Does Casbin Work?\\n\\nBefore diving into the implementation, it is important to understand what Casbin is and how it functions at a high level. This understanding is necessary because each Role-Based Access Control (RBAC) system may vary based on specific requirements. By grasping the workings of Casbin, we can effectively fine-tune the model.\\n\\n## What is ACL?\\n\\nACL stands for Access Control List. It is a method in which users are mapped to actions and actions to resources.\\n\\n### The model definition\\n\\nLet\'s consider a simple example of an ACL model.\\n\\n```toml\\n[request_definition]\\nr = sub, act, obj\\n\\n[policy_definition]\\np = sub, act, obj\\n\\n[policy_effect]\\ne = some(where (p.eft == allow))\\n\\n[matchers]\\nm = r.sub == p.sub && r.obj == p.obj && r.act == p.act\\n```\\n\\n1. The **request_definition** is the query template of the system. For example, a request `alice, write, data1` can be\\n   interpreted as \\"Can subject Alice perform the action \'write\' on object \'data1\'?\\".\\n\\n2. The **policy_definition** is the assignment template of the system. For example, by creating a policy `alice, write, data1`, you are\\n   assigning permission to subject Alice to perform the action \'write\' on object \'data1\'.\\n\\n3. The **policy_effect** defines the effect of the policy.\\n\\n4. In the **matchers** section, the request is matched with the policy using the conditions `r.sub == p.sub && r.obj == p.obj && r.act == p.act`.\\n\\n### Now let\'s test the model on the Casbin editor\\n\\nOpen the [editor](https://casbin.org/editor) and paste the above model in the Model editor.\\n\\nPaste the following in the Policy editor:\\n\\n```csv\\np, alice, read, data1\\np, bob, write, data2\\n```\\n\\nand the following in the Request editor:\\n\\n```csv\\nalice, read, data1\\n```\\n\\nThe result will be:\\n\\n```text\\ntrue\\n```\\n\\n### Visual representation of the ACL model, policy, and request matching\\n\\n![acl](/img/tutorial/acl.png)\\n\\n## What is RBAC?\\n\\nRBAC stands for Role-Based Access Control. In RBAC, a user is assigned a role for a resource, and a role can contain arbitrary actions. The request then checks if the user has the permission to perform the action on the resource.\\n\\n### The model definition\\n\\nLet\'s consider a simple example RBAC model:\\n\\n```toml\\n[request_definition]\\nr = sub, act, obj\\n\\n[policy_definition]\\np = sub, act, obj\\n\\n[role_definition]\\ng = _, _\\ng2 = _, _\\n\\n[policy_effect]\\ne = some(where (p.eft == allow))\\n\\n[matchers]\\nm = r.sub == p.sub && g(p.act, r.act) && r.obj == p.obj\\n```\\n\\n1. The **role_definition** is a graph relation builder that uses a Graph to compare the request object with the policy object.\\n\\n### Now let\'s test the model on Casbin editor\\n\\nOpen the [editor](https://casbin.org/editor) and paste the above model in the Model editor.\\n\\nPaste the following in the Policy editor:\\n\\n```csv\\np, alice, reader, data1\\np, bob, owner, data2\\n\\ng, reader, read\\ng, owner, read\\ng, owner, write\\n```\\n\\nand the following in the Request editor:\\n\\n```csv\\nalice, read, data1\\nalice, write, data1\\nbob, write, data2\\nbob, read, data2\\nbob, write, data1\\n```\\n\\nThe result will be:\\n\\n```text\\ntrue\\nfalse\\ntrue\\ntrue\\nfalse\\n```\\n\\n### Visual representation of the RBAC model, policy, and request matching\\n\\n![rbac](/img/tutorial/rbac.png)\\n\\nThe **g - Role to action mapping** table has a Graph mapping the role to action. This Graph can be coded as a list of edges, as shown in the policy which is a common way of representing a Graph:\\n\\n```csv\\ng, reader, read\\ng, owner, read\\ng, owner, write\\n```\\n\\n:::info\\n\\n**p** indicates a normal policy that can be compared using the **==** operator. **g** is a Graph-based comparison function. You can define multiple Graph comparators by adding a numerical suffix like **g, g2, g3, ...** and so on.\\n\\n:::\\n\\n## What is Hierarchical RBAC?\\n\\nIn Hierarchical RBAC, there are more than one type of resources and there is an inheritance relationship between the resource types. For example, \\"subscription\\" is one type and \\"resourceGroup\\" is another type. A sub1 of type **Subscription** can contain multiple resourceGroups (rg1, rg2) of type **ResourceGroup**.\\n\\nSimilar to the resource hierarchy, there will be two types of roles and actions: Subscription roles and actions, and ResourceGroup roles and actions. There is an arbitrary relationship between the Subscription role and ResourceGroup role. For example, consider a Subscription Role **sub-owner**. This role is inherited by a ResourceGroup Role **rg-owner**, which means that if I am assigned the **sub-owner** role on Subscription **sub1**, then I automatically also get the **rg-owner** role on **rg1 and rg2**.\\n\\n### The model definition\\n\\nLet\'s take a simple example of the **Hierarchical RBAC** model:\\n\\n```toml\\n[request_definition]\\nr = sub, act, obj\\n\\n[policy_definition]\\np = sub, act, obj\\n\\n[role_definition]\\ng = _, _\\ng2 = _, _\\n\\n[policy_effect]\\ne = some(where (p.eft == allow))\\n\\n[matchers]\\nm = r.sub == p.sub && g(p.act, r.act) && g2(p.obj, r.obj)\\n```\\n\\n1. The **role_definition** is a graph relation builder which uses a Graph to compare the request object with the policy object.\\n\\n### Now let\'s test the model on the Casbin editor\\n\\nOpen the [editor](https://casbin.org/editor) and paste the above model in the Model editor.\\n\\nPaste the following in the Policy editor:\\n\\n```csv\\np, alice, sub-reader, sub1\\np, bob, rg-owner, rg2\\n\\n// subscription role to subscription action mapping\\ng, sub-reader, sub-read\\ng, sub-owner, sub-read\\ng, sub-owner, sub-write\\n\\n// resourceGroup role to resourceGroup action mapping\\ng, rg-reader, rg-read\\ng, rg-owner, rg-read\\ng, rg-owner, rg-write\\n\\n// subscription role to resourceGroup role mapping\\ng, sub-reader, rg-reader\\ng, sub-owner, rg-owner\\n\\n// subscription resource to resourceGroup resource mapping\\ng2, sub1, rg1\\ng2, sub2, rg2\\n```\\n\\nAnd paste the following in the Request editor:\\n\\n```csv\\nalice, rg-read, rg1\\n```\\n\\nThe result will be:\\n\\n```text\\ntrue\\n```\\n\\n### Visual representation of the RBAC model, policy, and request matching\\n\\n![hrbac](/img/tutorial/hrbac.png)\\n\\nThe **g - Role to (Action, Role) Mapping** table has a graph mapping the role to the action, role mapping. This graph can be coded as a list of edges, as shown in the policy, which is a common way of representing a graph:\\n\\n```csv\\n// subscription role to subscription action mapping\\ng, sub-reader, sub-read\\ng, sub-owner, sub-read\\ng, sub-owner, sub-write\\n\\n// resourceGroup role to resourceGroup action mapping\\ng, rg-reader, rg-read\\ng, rg-owner, rg-read\\ng, rg-owner, rg-write\\n\\n// subscription role to resourceGroup role mapping\\ng, sub-reader, rg-reader\\ng, sub-owner, rg-owner\\n```\\n\\nThe **g2 - Sub to RG Mapping** table has a graph mapping subscription to resourceGroup:\\n\\n```csv\\n// subscription resource to resourceGroup resource mapping\\ng2, sub1, rg1\\ng2, sub2, rg2\\n```\\n\\n#### Subject Matching Visual representation\\n\\n![hrbac-sub-match](/img/tutorial/hrbac-sub-match.png)\\n\\n#### Action Matching Visual representation\\n\\n![hrbac-act-match](/img/tutorial/hrbac-act-match.png)\\n\\n#### Object Matching Visual representation\\n\\n![hrbac-obj-match](/img/tutorial/hrbac-obj-match.png)\\n\\n:::info\\n\\nWhen a request is submitted to Casbin, this matching happens for all the policies. If at least one policy matches, then the result of the request is true. If no policy matches the request, then the result is false.\\n\\n:::\\n\\n## Conclusion\\n\\nIn this tutorial, we learned about how different authorization models work and how they can be modeled using Casbin. In the second part of this tutorial, we will implement this in a demo Spring Boot Application and secure the APIs using Casbin."},{"id":"/2021/08/19/apisix-casbin-authorization","metadata":{"permalink":"/it/blog/2021/08/19/apisix-casbin-authorization","editUrl":"https://github.com/casbin/casbin-website-v2/edit/master/i18n/it/docusaurus-plugin-content-blog/2021-08-19-apisix-casbin-authorization.md","source":"@site/i18n/it/docusaurus-plugin-content-blog/2021-08-19-apisix-casbin-authorization.md","title":"Autorizzazione in APISIX utilizzando Casbin","description":"Introduzione","date":"2021-08-19T00:00:00.000Z","formattedDate":"19 agosto 2021","tags":[],"readingTime":5.54,"hasTruncateMarker":false,"authors":[{"name":"Rushikesh Tote","title":"Membro di Casbin","url":"http://github.com/rushitote","imageURL":"https://avatars.githubusercontent.com/rushitote"}],"frontMatter":{"title":"Autorizzazione in APISIX utilizzando Casbin","author":"Rushikesh Tote","authorTitle":"Membro di Casbin","authorURL":"http://github.com/rushitote","authorImageURL":"https://avatars.githubusercontent.com/rushitote"},"prevItem":{"title":"Understanding How Casbin Matching Works in Detail","permalink":"/it/blog/2023/12/08/understanding-casbin-matching-in-detail"},"nextItem":{"title":"Yang Luo - Vincitore del Google Open Source Peer Bonus","permalink":"/it/blog/2020/04/21/google-award"}},"content":"## Introduzione\\n\\n[APISIX](https://apisix.apache.org/) \xe8 un gateway API cloud nativo ad alte prestazioni e scalabile basato su Nginx e etcd. \xc8 un progetto open source della Apache Software Foundation. Oltre a ci\xf2, ci\xf2 che rende APISIX cos\xec buono \xe8 il supporto di molti ottimi plugin integrati che possono essere utilizzati per implementare funzionalit\xe0 come autenticazione, monitoraggio, routing, ecc. E il fatto che i plugin in APISIX siano ricaricati in modalit\xe0 \\"hot\\" (senza riavvii) lo rende molto dinamico.\\n\\nTuttavia, durante l\'uso di APISIX, potrebbero verificarsi scenari in cui potresti voler aggiungere logica di autorizzazione complessa nella tua applicazione. Questo \xe8 dove authz-casbin potrebbe aiutarti, authz-casbin \xe8 un plugin di APISIX basato su [Lua Casbin](https://github.com/casbin/lua-casbin/) che abilita un\'autorizzazione potente basata su vari modelli di controllo degli accessi. [Casbin](/) \xe8 una libreria di autorizzazione che supporta modelli di controllo degli accessi come ACL, RBAC, ABAC. Inizialmente scritto in Go, \xe8 stato portato in molte lingue e Lua Casbin \xe8 l\'implementazione Lua di Casbin. Lo sviluppo di authz-casbin \xe8 iniziato quando abbiamo proposto un nuovo plugin per l\'autorizzazione nel repository di APISIX ([#4674](https://github.com/apache/apisix/issues/4674)) a cui i membri core hanno dato il loro consenso. E dopo le utili revisioni che hanno portato a alcune modifiche e miglioramenti principali, la PR ([#4710](https://github.com/apache/apisix/pull/4710)) \xe8 stata finalmente unita.\\n\\nIn questo blog, useremo il plugin authz-casbin per mostrare come puoi implementare un modello di autorizzazione basato sul Controllo degli Accessi Basato sui Ruoli (RBAC) in APISIX.\\n\\n**NOTA**: Dovrai utilizzare qualche altro plugin o flusso di lavoro personalizzato per autenticare l\'utente poich\xe9 Casbin far\xe0 solo autorizzazione e non autenticazione.\\n\\n## Creazione di un modello\\n\\nIl plugin utilizza tre parametri per autorizzare qualsiasi richiesta - soggetto, oggetto e azione. Qui, il soggetto \xe8 il valore dell\'intestazione del nome utente, che potrebbe essere qualcosa come `[username: alice]`. Quindi, l\'oggetto \xe8 il percorso URL che viene acceduto e l\'azione \xe8 il metodo di richiesta utilizzato.\\n\\nDiciamo che vogliamo creare un modello con tre risorse nei percorsi - ``/`\\\\`, ``/res1`\\\\` e ``/res2`\\\\`. E vogliamo avere un modello come questo:\\n\\n![immagine](/img/blog/model.png)\\n\\nCi\xf2 significherebbe che tutti gli utenti (``*`\\\\`) come ad esempio ``jack`\\\\` possono accedere alla homepage (``/`\\\\`). E gli utenti con autorizzazioni di ``admin`\\\\` come ``alice`\\\\` e ``bob`\\\\` possono accedere a tutte le pagine e le risorse (come ``res1`\\\\` e ``res2`\\\\`). Inoltre, limitiamo gli utenti senza alcuna autorizzazione di amministratore all\'uso solo del metodo di richiesta ``GET`\\\\`. Per questo scenario, potremmo definire il modello come:\\n\\n```ini\\n[request_definition]\\nr = sub, obj, act\\n\\n[policy_definition]\\np = sub, obj, act\\n\\n[role_definition]\\ng = _, _\\n\\n[policy_effect]\\ne = some(where (p.eft == allow))\\n\\n[matchers]\\nm = (g(r.sub, p.sub) || keyMatch(r.sub, p.sub)) && keyMatch(r.obj, p.obj) && keyMatch(r.act, p.act)\\n```\\n\\n## Creazione di una politica\\n\\nDallo scenario sopra descritto, la politica sarebbe:\\n\\n```csv\\np, *, /, GET\\np, admin, *, *\\ng, alice, admin\\ng, bob, admin\\n```\\n\\nIl matcher dal modello significa:\\n\\n1. ``(g(r.sub, p.sub) || keyMatch(r.sub, p.sub))`\\\\`: O il soggetto della richiesta ha un ruolo come il soggetto della politica o il soggetto della richiesta corrisponde al soggetto della politica in ``keyMatch`\\\\`. ``keyMatch`\\\\` \xe8 una funzione incorporata in Lua Casbin, puoi dare un\'occhiata alla descrizione della funzione e ad altre funzioni simili che potrebbero essere utili [qui](https://github.com/casbin/lua-casbin/blob/master/src/util/BuiltInFunctions.lua).\\n2. ``keyMatch(r.obj, p.obj)`\\\\`: L\'oggetto della richiesta corrisponde all\'oggetto della politica (percorso URL qui).\\n3. ``keyMatch(r.act, p.act)`\\\\`: L\'azione della richiesta corrisponde all\'azione della politica (metodo di richiesta HTTP qui).\\n\\n## Abilitazione del plugin sulla route\\n\\nUna volta creato il modello e la politica, puoi abilitarlo su una route utilizzando l\'API di amministrazione di APISIX. Per abilitarlo utilizzando i percorsi dei file del modello e del policy:\\n\\n```sh\\ncurl http://127.0.0.1:9080/apisix/admin/routes/1 -H \'X-API-KEY: edd1c9f034335f136f87ad84b625c8f1\' -X PUT -d \'\\n{\\n    \\"plugins\\": {\\n        \\"authz-casbin\\": {\\n            \\"model_path\\": \\"/path/to/model.conf\\",\\n            \\"policy_path\\": \\"/path/to/policy.csv\\",\\n            \\"username\\": \\"username\\"\\n        }\\n    },\\n    \\"upstream\\": {\\n        \\"nodes\\": {\\n            \\"127.0.0.1:1980\\": 1\\n        },\\n        \\"type\\": \\"roundrobin\\"\\n    },\\n    \\"uri\\": \\"/*\\"\\n}\'\\n```\\n\\nQui, il campo username \xe8 il nome dell\'intestazione che utilizzerai per passare il soggetto. Ad esempio, se passer\xe0 l\'intestazione username come `user: alice`, dovresti usare `\\"username\\": \\"user\\"`.\\n\\nPer utilizzare il testo del modello/policy invece dei file, puoi utilizzare i campi `model` e `policy` al posto di:\\n\\n```sh\\ncurl http://127.0.0.1:9080/apisix/admin/routes/1 -H \'X-API-KEY: edd1c9f034335f136f87ad84b625c8f1\' -X PUT -d \'\\n{\\n    \\"plugins\\": {\\n        \\"authz-casbin\\": {\\n            \\"model\\": \\"[request_definition]\\n            r = sub, obj, act\\n\\n            [policy_definition]\\n            p = sub, obj, act\\n\\n            [role_definition]\\n            g = _, _\\n\\n            [policy_effect]\\n            e = some(where (p.eft == allow))\\n\\n            [matchers]\\n            m = (g(r.sub, p.sub) || keyMatch(r.sub, p.sub)) && keyMatch(r.obj, p.obj) && keyMatch(r.act, p.act)\\",\\n\\n            \\"policy\\": \\"p, *, /, GET\\n            p, admin, *, *\\n            g, alice, admin\\n            g, bob, admin\\",\\n\\n            \\"username\\": \\"username\\"\\n        }\\n    },\\n    \\"upstream\\": {\\n        \\"nodes\\": {\\n            \\"127.0.0.1:1980\\": 1\\n        },\\n        \\"type\\": \\"roundrobin\\"\\n    },\\n    \\"uri\\": \\"/*\\"\\n}\'\\n```\\n\\n## Abilitazione del plugin utilizzando un modello/policy globale\\n\\nPotrebbero esserci situazioni in cui potresti voler utilizzare una singola configurazione di modello e policy su pi\xf9 route. Puoi farlo prima inviando una richiesta `PUT` per aggiungere la configurazione del modello e della policy ai metadati del plugin:\\n\\n```sh\\ncurl http://127.0.0.1:9080/apisix/admin/plugin_metadata/authz-casbin -H \'X-API-KEY: edd1c9f034335f136f87ad84b625c8f1\' -i -X PUT -d \'\\n{\\n\\"model\\": \\"[request_definition]\\nr = sub, obj, act\\n\\n[policy_definition]\\np = sub, obj, act\\n\\n[role_definition]\\ng = _, _\\n\\n[policy_effect]\\ne = some(where (p.eft == allow))\\n\\n[matchers]\\nm = (g(r.sub, p.sub) || keyMatch(r.sub, p.sub)) && keyMatch(r.obj, p.obj) && keyMatch(r.act, p.act)\\",\\n\\n\\"policy\\": \\"p, *, /, GET\\np, admin, *, *\\ng, alice, admin\\ng, bob, admin\\"\\n}\'\\n```\\n\\nE poi per abilitare la stessa configurazione su una rotta, invia una richiesta utilizzando l\'API di Admin:\\n\\n```sh\\ncurl http://127.0.0.1:9080/apisix/admin/routes/1 -H \'X-API-KEY: edd1c9f034335f136f87ad84b625c8f1\' -X PUT -d \'\\n{\\n    \\"plugins\\": {\\n        \\"authz-casbin\\": {\\n            \\"username\\": \\"username\\"\\n        }\\n    },\\n    \\"upstream\\": {\\n        \\"nodes\\": {\\n            \\"127.0.0.1:1980\\": 1\\n        },\\n        \\"type\\": \\"roundrobin\\"\\n    },\\n    \\"uri\\": \\"/route1/*\\"\\n}\'\\n```\\n\\nQuesto aggiunger\xe0 la configurazione dei metadati del plugin alla rotta. Puoi anche facilmente aggiornare la configurazione dei metadati del plugin rispedendo la richiesta ai metadati del plugin con la configurazione del modello e della politica aggiornati, il plugin aggiorner\xe0 automaticamente tutte le rotte che utilizzano i metadati del plugin.\\n\\n## Casi d\'uso\\n\\n- Il caso d\'uso principale di questo plugin sarebbe nell\'implementazione dell\'autorizzazione nelle tue API. Puoi facilmente aggiungere questo plugin su qualsiasi rotta API che stai utilizzando con il tuo modello di autorizzazione e configurazione della politica.\\n- Se desideri avere un singolo modello di autorizzazione per tutte le tue API, puoi utilizzare il metodo del modello/politica globale. Questo rende facile l\'aggiornamento della politica per tutte le rotte, poich\xe9 devi solo aggiornare i metadati in etcd.\\n- Mentre se desideri utilizzare un modello diverso per ogni rotta diversa, puoi utilizzare il metodo della rotta. Questo \xe8 utile quando diverse route API hanno diversi set di permessi utente. Puoi anche utilizzare questo quando hai a che fare con politiche pi\xf9 grandi, poich\xe9 render\xe0 l\'autorizzazione pi\xf9 veloce quando filtrata in pi\xf9 route."},{"id":"/2020/04/21/google-award","metadata":{"permalink":"/it/blog/2020/04/21/google-award","editUrl":"https://github.com/casbin/casbin-website-v2/edit/master/i18n/it/docusaurus-plugin-content-blog/2020-04-21-google-award.md","source":"@site/i18n/it/docusaurus-plugin-content-blog/2020-04-21-google-award.md","title":"Yang Luo - Vincitore del Google Open Source Peer Bonus","description":"Oggi, siamo lieti di annunciare che il fondatore di Casbin, Yang Luo \xe8 stato insignito del premio \\"Google Open Source Peer Bonus winners\\" per il suo lavoro su Casbin, Npcap e Nmap nel terzo trimestre del 2019.","date":"2020-04-21T00:00:00.000Z","formattedDate":"21 aprile 2020","tags":[],"readingTime":0.81,"hasTruncateMarker":false,"authors":[{"name":"Casbin","title":"Account Ufficiale","url":"http://github.com/casbin","imageURL":"https://avatars.githubusercontent.com/casbin"}],"frontMatter":{"title":"Yang Luo - Vincitore del Google Open Source Peer Bonus","author":"Casbin","authorTitle":"Account Ufficiale","authorURL":"http://github.com/casbin","authorImageURL":"https://avatars.githubusercontent.com/casbin"},"prevItem":{"title":"Autorizzazione in APISIX utilizzando Casbin","permalink":"/it/blog/2021/08/19/apisix-casbin-authorization"},"nextItem":{"title":"Rielaborazione della nostra Documentazione","permalink":"/it/blog/2018/09/23/new-website"}},"content":"Oggi, siamo lieti di annunciare che il fondatore di Casbin, [Yang Luo](https://github.com/hsluoyz) \xe8 stato insignito del premio \\"Google Open Source Peer Bonus winners\\" per il suo lavoro su [Casbin](/), [Npcap](https://nmap.org/npcap/) e [Nmap](https://nmap.org/) nel terzo trimestre del 2019.\\n\\n![ospb](https://hsluoyz.github.io/download/Open%20Source%20Peer%20Bonus%20Q3%202019%20-%20Yang%20Luo%20-%20OSPB%20Award%20Letter.png)\\n\\n> La lettera originale del premio pu\xf2 essere acceduta [qui](https://github.com/hsluoyz/hsluoyz.github.io/blob/master/download/Open%20Source%20Peer%20Bonus%20Q3%202019%20-%20Yang%20Luo%20-%20OSPB%20Award%20Letter.pdf).\\n\\nIl programma [Google Open Source Peer Bonus](https://opensource.google.com/docs/growing/peer-bonus/) \xe8 descritto come:\\n\\n> _Allo stesso modo in cui un Google Peer Bonus viene utilizzato per riconoscere un collega Googler che ha superato le aspettative, un Open Source Peer Bonus riconosce persone esterne che hanno fatto contributi eccezionali all\'open source._\\n\\nL\'[annuncio per i vincitori del 2019](https://opensource.googleblog.com/2020/01/announcing-2019-second-cycle-google.html) \xe8 disponibile all\'indirizzo:\\n\\n> https://opensource.googleblog.com/2020/01/announcing-2019-second-cycle-google.html\\n\\nYang e Casbin sono elencati tra gli sviluppatori e i progetti open source che hanno un impatto rilevante l\xe0 fuori, come Git, TensorFlow, V8, CPython, LLVM, progetti Apache, Angular o Jenkins.\\n\\nSiamo lieti di vedere Casbin riconosciuto in questo modo per il suo contributo all\'open source e alla sicurezza del cloud!\\n\\n_Grazie per volare con Casbin!_"},{"id":"/2018/09/23/new-website","metadata":{"permalink":"/it/blog/2018/09/23/new-website","editUrl":"https://github.com/casbin/casbin-website-v2/edit/master/i18n/it/docusaurus-plugin-content-blog/2018-09-23-new-website.md","source":"@site/i18n/it/docusaurus-plugin-content-blog/2018-09-23-new-website.md","title":"Rielaborazione della nostra Documentazione","description":"Oggi, abbiamo migrato la documentazione di Casbin dalla GitHub Wiki alla sezione Docs di questo sito web, Docusaurus offre molte fantastiche funzionalit\xe0 come stili Markdown migliori, ricerca full-text, versionamento, traduzione.","date":"2018-09-23T00:00:00.000Z","formattedDate":"23 settembre 2018","tags":[],"readingTime":0.265,"hasTruncateMarker":false,"authors":[{"name":"Yang Luo","title":"Creatore di Casbin","url":"http://github.com/hsluoyz","imageURL":"https://avatars.githubusercontent.com/hsluoyz"}],"frontMatter":{"title":"Rielaborazione della nostra Documentazione","author":"Yang Luo","authorTitle":"Creatore di Casbin","authorURL":"http://github.com/hsluoyz","authorImageURL":"https://avatars.githubusercontent.com/hsluoyz"},"prevItem":{"title":"Yang Luo - Vincitore del Google Open Source Peer Bonus","permalink":"/it/blog/2020/04/21/google-award"},"nextItem":{"title":"node-Casbin: Nuovo Membro della Famiglia Casbin","permalink":"/it/blog/2018/08/27/node-casbin"}},"content":"Oggi, abbiamo migrato la documentazione di Casbin dalla GitHub Wiki alla sezione `Docs` di questo sito web, Docusaurus offre molte fantastiche funzionalit\xe0 come stili Markdown migliori, ricerca full-text, versionamento, traduzione.\\n\\nLa documentazione non \xe8 ancora perfetta e necessita ancora di ottimizzazione. Il codice sorgente \xe8 ospitato\\n\\nQualsiasi contributo o suggerimento \xe8 il benvenuto!"},{"id":"/2018/08/27/node-casbin","metadata":{"permalink":"/it/blog/2018/08/27/node-casbin","editUrl":"https://github.com/casbin/casbin-website-v2/edit/master/i18n/it/docusaurus-plugin-content-blog/2018-08-27-node-casbin.md","source":"@site/i18n/it/docusaurus-plugin-content-blog/2018-08-27-node-casbin.md","title":"node-Casbin: Nuovo Membro della Famiglia Casbin","description":"Oggi, abbiamo portato con successo Casbin su Node.js, che \xe8 stato chiamato:","date":"2018-08-27T00:00:00.000Z","formattedDate":"27 agosto 2018","tags":[],"readingTime":0.23,"hasTruncateMarker":false,"authors":[{"name":"Zixuan Liu","title":"Manutentore di Casbin","url":"http://github.com/nodece","imageURL":"https://avatars.githubusercontent.com/nodece"}],"frontMatter":{"title":"node-Casbin: Nuovo Membro della Famiglia Casbin","author":"Zixuan Liu","authorTitle":"Manutentore di Casbin","authorURL":"http://github.com/nodece","authorImageURL":"https://avatars.githubusercontent.com/nodece"},"prevItem":{"title":"Rielaborazione della nostra Documentazione","permalink":"/it/blog/2018/09/23/new-website"},"nextItem":{"title":"Casbin Server \xe8 stato lanciato!","permalink":"/it/blog/2018/08/07/launching-casbin-server"}},"content":"Oggi, abbiamo portato con successo Casbin su Node.js, che \xe8 stato chiamato:\\n\\n**node-Casbin** condivide un utilizzo e API simili I middleware per Express, Koa2 e Egg.js sono pronti L\'adattatore di storage per Sequelize \xe8 anche preparato.\\n\\nSpero possa soddisfare le tue esigenze bene :)\\n\\nGitHub: https://github.com/casbin/node-casbin"},{"id":"/2018/08/07/launching-casbin-server","metadata":{"permalink":"/it/blog/2018/08/07/launching-casbin-server","editUrl":"https://github.com/casbin/casbin-website-v2/edit/master/i18n/it/docusaurus-plugin-content-blog/2018-08-07-launching-casbin-server.md","source":"@site/i18n/it/docusaurus-plugin-content-blog/2018-08-07-launching-casbin-server.md","title":"Casbin Server \xe8 stato lanciato!","description":"Alcuni dei nostri clienti chiedono se Casbin pu\xf2 essere utilizzato come servizio invece che come libreria. La risposta \xe8 S\xcc. Oggi, abbiamo lanciato il progetto Casbin Server come soluzione concreta per","date":"2018-08-07T00:00:00.000Z","formattedDate":"7 agosto 2018","tags":[],"readingTime":0.735,"hasTruncateMarker":false,"authors":[{"name":"Helong Zhang","title":"Manutentore di Casbin","url":"http://github.com/BetaCat0","imageURL":"https://avatars.githubusercontent.com/BetaCat0"}],"frontMatter":{"title":"Casbin Server \xe8 stato lanciato!","author":"Helong Zhang","authorTitle":"Manutentore di Casbin","authorURL":"http://github.com/BetaCat0","authorImageURL":"https://avatars.githubusercontent.com/BetaCat0"},"prevItem":{"title":"node-Casbin: Nuovo Membro della Famiglia Casbin","permalink":"/it/blog/2018/08/27/node-casbin"}},"content":"Alcuni dei nostri clienti chiedono se Casbin pu\xf2 essere utilizzato come servizio invece che come libreria. La risposta \xe8 **S\xcc**. Oggi, abbiamo lanciato il progetto [Casbin Server](https://github.com/casbin/casbin-server) come soluzione concreta per\\n\\n**Casbin Server** \xe8 in fase di sviluppo attivo da parte del nostro team principale. Presenta diverse funzionalit\xe0:\\n\\n- Sviluppato esclusivamente in Golang.\\n- Pu\xf2 gestire migliaia di istanze Casbin, consentendo di spostare la logica di applicazione dei criteri da pi\xf9 servizi in un unico Casbin Server.\\n- **gRPC** viene utilizzato per comunicare con Casbin Server. Consideriamo anche di aggiungere il supporto **RESTful** nel prossimo futuro.\\n- \xc8 fornito un portale amministratore web intuitivo per consentire agli amministratori non sviluppatori di gestire tutti i dettagli come istanze Casbin, modelli, archiviazione dei criteri e bilanciamento del carico.\\n\\n\\n\\nIl codice sorgente \xe8 ospitato su GitHub: https://github.com/casbin/casbin-server\\n\\nTutte le segnalazioni di problemi o le richieste di pull sono benvenute :)"}]}')}}]);