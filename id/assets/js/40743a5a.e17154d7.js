"use strict";(globalThis.webpackChunkcasbin_website_v2=globalThis.webpackChunkcasbin_website_v2||[]).push([[128],{8453(e,n,s){s.d(n,{R:()=>a,x:()=>o});var i=s(6540);const r={},t=i.createContext(r);function a(e){const n=i.useContext(t);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),i.createElement(t.Provider,{value:n},e.children)}},9447(e,n,s){s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>p,frontMatter:()=>a,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"abac","title":"ABAC","description":"ABAC berbasis Casbin","source":"@site/i18n/id/docusaurus-plugin-content-docs/current/ABAC.mdx","sourceDirName":".","slug":"/abac","permalink":"/id/docs/abac","draft":false,"unlisted":false,"editUrl":"https://github.com/casbin/casbin-website-v2/edit/master/docs/ABAC.mdx","tags":[],"version":"current","frontMatter":{"id":"abac","title":"ABAC","description":"ABAC berbasis Casbin","keywords":["ABAC","ABAC model"],"authors":["hsluoyz"]},"sidebar":"docs","previous":{"title":"ReBAC","permalink":"/id/docs/rebac"},"next":{"title":"PBAC","permalink":"/id/docs/pbac"}}');var r=s(4848),t=s(8453);const a={id:"abac",title:"ABAC",description:"ABAC berbasis Casbin",keywords:["ABAC","ABAC model"],authors:["hsluoyz"]},o=void 0,c={},l=[{value:"What is ABAC?",id:"what-is-abac",level:2},{value:"Using ABAC",id:"using-abac",level:2},{value:"Complex rules with <code>eval()</code>",id:"complex-rules-with-eval",level:2}];function d(e){const n={admonition:"admonition",code:"code",h2:"h2",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h2,{id:"what-is-abac",children:"What is ABAC?"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Attribute-Based Access Control (ABAC)"})," decides access by evaluating ",(0,r.jsx)(n.strong,{children:"attributes"})," of the subject, object, and action (e.g. ",(0,r.jsx)(n.code,{children:"resource.Owner"}),", ",(0,r.jsx)(n.code,{children:"user.Role"}),"), not just by identity strings. Casbin keeps this simple: you pass structs or objects into ",(0,r.jsx)(n.code,{children:"Enforce()"})," and reference their fields in the matcher."]}),"\n",(0,r.jsx)(n.p,{children:"Minimal example:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ini",children:"[request_definition]\nr = sub, obj, act\n\n[policy_definition]\np = sub, obj, act\n\n[policy_effect]\ne = some(where (p.eft == allow))\n\n[matchers]\nm = r.sub == r.obj.Owner\n"})}),"\n",(0,r.jsxs)(n.p,{children:["So ",(0,r.jsx)(n.code,{children:"r.obj"})," must be an object with an ",(0,r.jsx)(n.code,{children:"Owner"})," field; Casbin reads it via reflection. In Go you might define:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",children:"type testResource struct {\n    Name  string\n    Owner string\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["You can also pass ",(0,r.jsx)(n.strong,{children:"JSON strings"}),"; enable JSON handling and Casbin will parse them:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",children:'e, _ := NewEnforcer("examples/abac_model.conf")\ne.EnableAcceptJsonRequest(true)\n\ndata1Json := `{ "Name": "data1", "Owner": "bob"}`\n\nok, err := e.Enforce("alice", data1Json, "read")\nif err != nil {\n    // Handle JSON parsing errors\n    fmt.Printf("Enforcement failed: %v\\n", err)\n    return\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:["When enabled, any parameter that starts with ",(0,r.jsx)(n.code,{children:"{"})," or ",(0,r.jsx)(n.code,{children:"["})," is parsed as JSON. Invalid JSON produces a clear error; other strings are left as-is."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",children:'// Valid JSON - automatically parsed\nvalidJSON := `{"Name": "alice", "Age": 25}`\nok, err := e.Enforce(validJSON, "data1", "read")  // Works correctly\n\n// Invalid JSON - returns descriptive error\ninvalidJSON := `{"Name": "alice",}`  // Trailing comma is invalid in JSON\nok, err := e.Enforce(invalidJSON, "data1", "read")\n// Returns: "failed to parse JSON parameter at index 0: ..."\n\n// Plain string - no parsing attempted\nplainString := "alice"\nok, err := e.Enforce(plainString, "data1", "read")  // Treated as plain string\n'})}),"\n",(0,r.jsx)(n.admonition,{type:"note",children:(0,r.jsx)(n.p,{children:"Enabling JSON parameter support introduces a performance overhead of approximately 1.1 to 1.5x."})}),"\n",(0,r.jsx)(n.h2,{id:"using-abac",children:"Using ABAC"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["Reference attributes in the matcher (e.g. ",(0,r.jsx)(n.code,{children:"r.sub.Role"}),", ",(0,r.jsx)(n.code,{children:"r.obj.Owner"}),")."]}),"\n",(0,r.jsxs)(n.li,{children:["Pass struct or class instances (or JSON) into ",(0,r.jsx)(n.code,{children:"Enforce()"}),"."]}),"\n"]}),"\n",(0,r.jsx)(n.admonition,{type:"warning",children:(0,r.jsxs)(n.p,{children:["ABAC attribute access works only for request elements (",(0,r.jsx)(n.code,{children:"r.sub"}),", ",(0,r.jsx)(n.code,{children:"r.obj"}),", ",(0,r.jsx)(n.code,{children:"r.act"}),"). Policy elements like ",(0,r.jsx)(n.code,{children:"p.sub"})," cannot use ABAC since policies cannot store struct or class definitions."]})}),"\n",(0,r.jsx)(n.admonition,{type:"tip",children:(0,r.jsxs)(n.p,{children:["Matchers can reference multiple attributes simultaneously. Example: ",(0,r.jsx)(n.code,{children:"m = r.sub.Domain == r.obj.Domain"}),"."]})}),"\n",(0,r.jsx)(n.admonition,{type:"tip",children:(0,r.jsxs)(n.p,{children:["When policies require commas that would conflict with CSV parsing, wrap the expression in quotation marks. Example: ",(0,r.jsx)(n.code,{children:'"keyMatch("bob", r.sub.Role)"'})," prevents unwanted splitting."]})}),"\n",(0,r.jsxs)(n.h2,{id:"complex-rules-with-eval",children:["Complex rules with ",(0,r.jsx)(n.code,{children:"eval()"})]}),"\n",(0,r.jsxs)(n.p,{children:["For more complex conditions, put expressions in ",(0,r.jsx)(n.strong,{children:"policy"})," and evaluate them with ",(0,r.jsx)(n.code,{children:"eval()"})," so the model stays small and policies stay flexible."]}),"\n",(0,r.jsxs)(n.p,{children:["Model configuration with ",(0,r.jsx)(n.code,{children:"eval()"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ini",children:"[request_definition]\nr = sub, obj, act\n\n[policy_definition]\np = sub_rule, obj, act\n\n[policy_effect]\ne = some(where (p.eft == allow))\n\n[matchers]\nm = eval(p.sub_rule) && r.obj == p.obj && r.act == p.act\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"p.sub_rule"})," is an expression over request attributes, evaluated at enforce time. Example policy:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csv",children:"p, r.sub.Age > 18, /data1, read\np, r.sub.Age < 60, /data2, write\n"})})]})}function p(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}}}]);