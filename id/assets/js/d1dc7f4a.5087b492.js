"use strict";(globalThis.webpackChunkcasbin_website_v2=globalThis.webpackChunkcasbin_website_v2||[]).push([[8323],{1469(e,i,t){t.r(i),t.d(i,{assets:()=>l,contentTitle:()=>a,default:()=>p,frontMatter:()=>r,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"policy-subset-loading","title":"Loading Policy Subsets","description":"Memuat kebijakan terfilter","source":"@site/i18n/id/docusaurus-plugin-content-docs/current/PolicySubsetLoading.mdx","sourceDirName":".","slug":"/policy-subset-loading","permalink":"/id/docs/policy-subset-loading","draft":false,"unlisted":false,"editUrl":"https://github.com/casbin/casbin-website-v2/edit/master/docs/PolicySubsetLoading.mdx","tags":[],"version":"current","frontMatter":{"id":"policy-subset-loading","title":"Loading Policy Subsets","description":"Memuat kebijakan terfilter","keywords":["filtered policies","policy subset","performance optimization"],"authors":["hsluoyz"]},"sidebar":"docs","previous":{"title":"Policy Storage","permalink":"/id/docs/policy-storage"},"next":{"title":"Use Cases","permalink":"/id/docs/category/use-cases"}}');var n=t(4848),s=t(8453);const r={id:"policy-subset-loading",title:"Loading Policy Subsets",description:"Memuat kebijakan terfilter",keywords:["filtered policies","policy subset","performance optimization"],authors:["hsluoyz"]},a=void 0,l={},c=[];function d(e){const i={a:"a",code:"code",p:"p",pre:"pre",strong:"strong",...(0,s.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(i.p,{children:["Some ",(0,n.jsx)(i.a,{href:"/docs/adapters",children:"adapters"})," support ",(0,n.jsx)(i.strong,{children:"filtered policy loading"}),": only a subset of policies is loaded from storage according to a filter. That reduces memory and speed in large or multi-tenant setups where loading the full policy set is impractical."]}),"\n",(0,n.jsxs)(i.p,{children:["Call ",(0,n.jsx)(i.code,{children:"LoadFilteredPolicy(filter)"})," with a supported adapter. The filter shape is adapter-specific. When using filtered loading, ",(0,n.jsx)(i.code,{children:"SavePolicy()"})," is disabled so you don\u2019t overwrite the full policy by mistake."]}),"\n",(0,n.jsxs)(i.p,{children:["Example: filtered file adapter with an RBAC-with-domains model. The filter loads only policies for ",(0,n.jsx)(i.code,{children:"domain1"}),":"]}),"\n",(0,n.jsx)(i.pre,{children:(0,n.jsx)(i.code,{className:"language-go",children:'import (\n    "github.com/casbin/casbin/v3"\n    fileadapter "github.com/casbin/casbin/v3/persist/file-adapter"\n)\n\nenforcer, _ := casbin.NewEnforcer()\n\nadapter := fileadapter.NewFilteredAdapter("examples/rbac_with_domains_policy.csv")\nenforcer.InitWithAdapter("examples/rbac_with_domains_model.conf", adapter)\n\nfilter := &fileadapter.Filter{\n    P: []string{"", "domain1"},\n    G: []string{"", "", "domain1"},\n}\nenforcer.LoadFilteredPolicy(filter)\n\n// Only policies for "domain1" are loaded.\n'})}),"\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.code,{children:"LoadIncrementalFilteredPolicy(filter)"})," works like ",(0,n.jsx)(i.code,{children:"LoadFilteredPolicy"})," but ",(0,n.jsx)(i.strong,{children:"adds"})," the filtered policies to the current in-memory policy instead of replacing it. You can combine several filtered loads (e.g. per tenant) into one enforcer."]})]})}function p(e={}){const{wrapper:i}={...(0,s.R)(),...e.components};return i?(0,n.jsx)(i,{...e,children:(0,n.jsx)(d,{...e})}):d(e)}},8453(e,i,t){t.d(i,{R:()=>r,x:()=>a});var o=t(6540);const n={},s=o.createContext(n);function r(e){const i=o.useContext(s);return o.useMemo(function(){return"function"==typeof e?e(i):{...i,...e}},[i,e])}function a(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:r(e.components),o.createElement(s.Provider,{value:i},e.children)}}}]);